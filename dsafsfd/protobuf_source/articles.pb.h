// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: articles.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_articles_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_articles_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021008 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_articles_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_articles_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_articles_2eproto;
namespace np2ps {
class Article;
struct ArticleDefaultTypeInternal;
extern ArticleDefaultTypeInternal _Article_default_instance_;
class Article_MarginsEntry_DoNotUse;
struct Article_MarginsEntry_DoNotUseDefaultTypeInternal;
extern Article_MarginsEntry_DoNotUseDefaultTypeInternal _Article_MarginsEntry_DoNotUse_default_instance_;
class Article_ParagraphHashesEntry_DoNotUse;
struct Article_ParagraphHashesEntry_DoNotUseDefaultTypeInternal;
extern Article_ParagraphHashesEntry_DoNotUseDefaultTypeInternal _Article_ParagraphHashesEntry_DoNotUse_default_instance_;
class HashWrapper;
struct HashWrapperDefaultTypeInternal;
extern HashWrapperDefaultTypeInternal _HashWrapper_default_instance_;
class Margin;
struct MarginDefaultTypeInternal;
extern MarginDefaultTypeInternal _Margin_default_instance_;
class Margins;
struct MarginsDefaultTypeInternal;
extern MarginsDefaultTypeInternal _Margins_default_instance_;
class SerializedArticle;
struct SerializedArticleDefaultTypeInternal;
extern SerializedArticleDefaultTypeInternal _SerializedArticle_default_instance_;
}  // namespace np2ps
PROTOBUF_NAMESPACE_OPEN
template<> ::np2ps::Article* Arena::CreateMaybeMessage<::np2ps::Article>(Arena*);
template<> ::np2ps::Article_MarginsEntry_DoNotUse* Arena::CreateMaybeMessage<::np2ps::Article_MarginsEntry_DoNotUse>(Arena*);
template<> ::np2ps::Article_ParagraphHashesEntry_DoNotUse* Arena::CreateMaybeMessage<::np2ps::Article_ParagraphHashesEntry_DoNotUse>(Arena*);
template<> ::np2ps::HashWrapper* Arena::CreateMaybeMessage<::np2ps::HashWrapper>(Arena*);
template<> ::np2ps::Margin* Arena::CreateMaybeMessage<::np2ps::Margin>(Arena*);
template<> ::np2ps::Margins* Arena::CreateMaybeMessage<::np2ps::Margins>(Arena*);
template<> ::np2ps::SerializedArticle* Arena::CreateMaybeMessage<::np2ps::SerializedArticle>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace np2ps {

// ===================================================================

class HashWrapper final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:np2ps.HashWrapper) */ {
 public:
  inline HashWrapper() : HashWrapper(nullptr) {}
  ~HashWrapper() override;
  explicit PROTOBUF_CONSTEXPR HashWrapper(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HashWrapper(const HashWrapper& from);
  HashWrapper(HashWrapper&& from) noexcept
    : HashWrapper() {
    *this = ::std::move(from);
  }

  inline HashWrapper& operator=(const HashWrapper& from) {
    CopyFrom(from);
    return *this;
  }
  inline HashWrapper& operator=(HashWrapper&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HashWrapper& default_instance() {
    return *internal_default_instance();
  }
  static inline const HashWrapper* internal_default_instance() {
    return reinterpret_cast<const HashWrapper*>(
               &_HashWrapper_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(HashWrapper& a, HashWrapper& b) {
    a.Swap(&b);
  }
  inline void Swap(HashWrapper* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HashWrapper* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HashWrapper* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HashWrapper>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HashWrapper& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HashWrapper& from) {
    HashWrapper::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HashWrapper* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "np2ps.HashWrapper";
  }
  protected:
  explicit HashWrapper(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHashFieldNumber = 1,
    kLevelFieldNumber = 2,
  };
  // uint64 hash = 1;
  void clear_hash();
  uint64_t hash() const;
  void set_hash(uint64_t value);
  private:
  uint64_t _internal_hash() const;
  void _internal_set_hash(uint64_t value);
  public:

  // uint32 level = 2;
  void clear_level();
  uint32_t level() const;
  void set_level(uint32_t value);
  private:
  uint32_t _internal_level() const;
  void _internal_set_level(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:np2ps.HashWrapper)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t hash_;
    uint32_t level_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_articles_2eproto;
};
// -------------------------------------------------------------------

class Margin final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:np2ps.Margin) */ {
 public:
  inline Margin() : Margin(nullptr) {}
  ~Margin() override;
  explicit PROTOBUF_CONSTEXPR Margin(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Margin(const Margin& from);
  Margin(Margin&& from) noexcept
    : Margin() {
    *this = ::std::move(from);
  }

  inline Margin& operator=(const Margin& from) {
    CopyFrom(from);
    return *this;
  }
  inline Margin& operator=(Margin&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Margin& default_instance() {
    return *internal_default_instance();
  }
  static inline const Margin* internal_default_instance() {
    return reinterpret_cast<const Margin*>(
               &_Margin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Margin& a, Margin& b) {
    a.Swap(&b);
  }
  inline void Swap(Margin* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Margin* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Margin* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Margin>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Margin& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Margin& from) {
    Margin::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Margin* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "np2ps.Margin";
  }
  protected:
  explicit Margin(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kContentFieldNumber = 2,
    kIdFieldNumber = 3,
  };
  // string type = 1;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // string content = 2;
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // uint64 id = 3;
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:np2ps.Margin)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
    uint64_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_articles_2eproto;
};
// -------------------------------------------------------------------

class Margins final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:np2ps.Margins) */ {
 public:
  inline Margins() : Margins(nullptr) {}
  ~Margins() override;
  explicit PROTOBUF_CONSTEXPR Margins(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Margins(const Margins& from);
  Margins(Margins&& from) noexcept
    : Margins() {
    *this = ::std::move(from);
  }

  inline Margins& operator=(const Margins& from) {
    CopyFrom(from);
    return *this;
  }
  inline Margins& operator=(Margins&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Margins& default_instance() {
    return *internal_default_instance();
  }
  static inline const Margins* internal_default_instance() {
    return reinterpret_cast<const Margins*>(
               &_Margins_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Margins& a, Margins& b) {
    a.Swap(&b);
  }
  inline void Swap(Margins* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Margins* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Margins* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Margins>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Margins& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Margins& from) {
    Margins::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Margins* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "np2ps.Margins";
  }
  protected:
  explicit Margins(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarginsFieldNumber = 1,
  };
  // repeated .np2ps.Margin margins = 1;
  int margins_size() const;
  private:
  int _internal_margins_size() const;
  public:
  void clear_margins();
  ::np2ps::Margin* mutable_margins(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::np2ps::Margin >*
      mutable_margins();
  private:
  const ::np2ps::Margin& _internal_margins(int index) const;
  ::np2ps::Margin* _internal_add_margins();
  public:
  const ::np2ps::Margin& margins(int index) const;
  ::np2ps::Margin* add_margins();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::np2ps::Margin >&
      margins() const;

  // @@protoc_insertion_point(class_scope:np2ps.Margins)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::np2ps::Margin > margins_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_articles_2eproto;
};
// -------------------------------------------------------------------

class Article_ParagraphHashesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Article_ParagraphHashesEntry_DoNotUse, 
    int32_t, ::np2ps::HashWrapper,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Article_ParagraphHashesEntry_DoNotUse, 
    int32_t, ::np2ps::HashWrapper,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  Article_ParagraphHashesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Article_ParagraphHashesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Article_ParagraphHashesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Article_ParagraphHashesEntry_DoNotUse& other);
  static const Article_ParagraphHashesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Article_ParagraphHashesEntry_DoNotUse*>(&_Article_ParagraphHashesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_articles_2eproto;
};

// -------------------------------------------------------------------

class Article_MarginsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Article_MarginsEntry_DoNotUse, 
    uint64_t, ::np2ps::Margins,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Article_MarginsEntry_DoNotUse, 
    uint64_t, ::np2ps::Margins,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  Article_MarginsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Article_MarginsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Article_MarginsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Article_MarginsEntry_DoNotUse& other);
  static const Article_MarginsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Article_MarginsEntry_DoNotUse*>(&_Article_MarginsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_articles_2eproto;
};

// -------------------------------------------------------------------

class Article final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:np2ps.Article) */ {
 public:
  inline Article() : Article(nullptr) {}
  ~Article() override;
  explicit PROTOBUF_CONSTEXPR Article(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Article(const Article& from);
  Article(Article&& from) noexcept
    : Article() {
    *this = ::std::move(from);
  }

  inline Article& operator=(const Article& from) {
    CopyFrom(from);
    return *this;
  }
  inline Article& operator=(Article&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Article& default_instance() {
    return *internal_default_instance();
  }
  static inline const Article* internal_default_instance() {
    return reinterpret_cast<const Article*>(
               &_Article_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Article& a, Article& b) {
    a.Swap(&b);
  }
  inline void Swap(Article* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Article* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Article* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Article>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Article& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Article& from) {
    Article::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Article* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "np2ps.Article";
  }
  protected:
  explicit Article(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kParagraphHashesFieldNumber = 7,
    kCategoriesFieldNumber = 9,
    kMarginsFieldNumber = 10,
    kAuthorNameFieldNumber = 1,
    kNewsNameFieldNumber = 3,
    kHeadingFieldNumber = 6,
    kCryptoHashFieldNumber = 12,
    kAuthorIdFieldNumber = 2,
    kNewsIdFieldNumber = 4,
    kMainHashFieldNumber = 5,
    kLengthFieldNumber = 8,
    kCreationTimeFieldNumber = 13,
    kModificationTimeFieldNumber = 14,
    kTypeFieldNumber = 11,
  };
  // map<int32, .np2ps.HashWrapper> paragraph_hashes = 7;
  int paragraph_hashes_size() const;
  private:
  int _internal_paragraph_hashes_size() const;
  public:
  void clear_paragraph_hashes();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::np2ps::HashWrapper >&
      _internal_paragraph_hashes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::np2ps::HashWrapper >*
      _internal_mutable_paragraph_hashes();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::np2ps::HashWrapper >&
      paragraph_hashes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::np2ps::HashWrapper >*
      mutable_paragraph_hashes();

  // repeated string categories = 9;
  int categories_size() const;
  private:
  int _internal_categories_size() const;
  public:
  void clear_categories();
  const std::string& categories(int index) const;
  std::string* mutable_categories(int index);
  void set_categories(int index, const std::string& value);
  void set_categories(int index, std::string&& value);
  void set_categories(int index, const char* value);
  void set_categories(int index, const char* value, size_t size);
  std::string* add_categories();
  void add_categories(const std::string& value);
  void add_categories(std::string&& value);
  void add_categories(const char* value);
  void add_categories(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& categories() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_categories();
  private:
  const std::string& _internal_categories(int index) const;
  std::string* _internal_add_categories();
  public:

  // map<uint64, .np2ps.Margins> margins = 10;
  int margins_size() const;
  private:
  int _internal_margins_size() const;
  public:
  void clear_margins();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::np2ps::Margins >&
      _internal_margins() const;
  ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::np2ps::Margins >*
      _internal_mutable_margins();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::np2ps::Margins >&
      margins() const;
  ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::np2ps::Margins >*
      mutable_margins();

  // optional string author_name = 1;
  bool has_author_name() const;
  private:
  bool _internal_has_author_name() const;
  public:
  void clear_author_name();
  const std::string& author_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_author_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_author_name();
  PROTOBUF_NODISCARD std::string* release_author_name();
  void set_allocated_author_name(std::string* author_name);
  private:
  const std::string& _internal_author_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_author_name(const std::string& value);
  std::string* _internal_mutable_author_name();
  public:

  // optional string news_name = 3;
  bool has_news_name() const;
  private:
  bool _internal_has_news_name() const;
  public:
  void clear_news_name();
  const std::string& news_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_news_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_news_name();
  PROTOBUF_NODISCARD std::string* release_news_name();
  void set_allocated_news_name(std::string* news_name);
  private:
  const std::string& _internal_news_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_news_name(const std::string& value);
  std::string* _internal_mutable_news_name();
  public:

  // string heading = 6;
  void clear_heading();
  const std::string& heading() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_heading(ArgT0&& arg0, ArgT... args);
  std::string* mutable_heading();
  PROTOBUF_NODISCARD std::string* release_heading();
  void set_allocated_heading(std::string* heading);
  private:
  const std::string& _internal_heading() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_heading(const std::string& value);
  std::string* _internal_mutable_heading();
  public:

  // bytes crypto_hash = 12;
  void clear_crypto_hash();
  const std::string& crypto_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_crypto_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_crypto_hash();
  PROTOBUF_NODISCARD std::string* release_crypto_hash();
  void set_allocated_crypto_hash(std::string* crypto_hash);
  private:
  const std::string& _internal_crypto_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_crypto_hash(const std::string& value);
  std::string* _internal_mutable_crypto_hash();
  public:

  // uint64 author_id = 2;
  void clear_author_id();
  uint64_t author_id() const;
  void set_author_id(uint64_t value);
  private:
  uint64_t _internal_author_id() const;
  void _internal_set_author_id(uint64_t value);
  public:

  // uint64 news_id = 4;
  void clear_news_id();
  uint64_t news_id() const;
  void set_news_id(uint64_t value);
  private:
  uint64_t _internal_news_id() const;
  void _internal_set_news_id(uint64_t value);
  public:

  // uint64 main_hash = 5;
  void clear_main_hash();
  uint64_t main_hash() const;
  void set_main_hash(uint64_t value);
  private:
  uint64_t _internal_main_hash() const;
  void _internal_set_main_hash(uint64_t value);
  public:

  // uint64 length = 8;
  void clear_length();
  uint64_t length() const;
  void set_length(uint64_t value);
  private:
  uint64_t _internal_length() const;
  void _internal_set_length(uint64_t value);
  public:

  // int64 creation_time = 13;
  void clear_creation_time();
  int64_t creation_time() const;
  void set_creation_time(int64_t value);
  private:
  int64_t _internal_creation_time() const;
  void _internal_set_creation_time(int64_t value);
  public:

  // int64 modification_time = 14;
  void clear_modification_time();
  int64_t modification_time() const;
  void set_modification_time(int64_t value);
  private:
  int64_t _internal_modification_time() const;
  void _internal_set_modification_time(int64_t value);
  public:

  // uint32 type = 11;
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:np2ps.Article)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Article_ParagraphHashesEntry_DoNotUse,
        int32_t, ::np2ps::HashWrapper,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> paragraph_hashes_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> categories_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Article_MarginsEntry_DoNotUse,
        uint64_t, ::np2ps::Margins,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> margins_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr author_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr news_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr heading_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr crypto_hash_;
    uint64_t author_id_;
    uint64_t news_id_;
    uint64_t main_hash_;
    uint64_t length_;
    int64_t creation_time_;
    int64_t modification_time_;
    uint32_t type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_articles_2eproto;
};
// -------------------------------------------------------------------

class SerializedArticle final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:np2ps.SerializedArticle) */ {
 public:
  inline SerializedArticle() : SerializedArticle(nullptr) {}
  ~SerializedArticle() override;
  explicit PROTOBUF_CONSTEXPR SerializedArticle(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SerializedArticle(const SerializedArticle& from);
  SerializedArticle(SerializedArticle&& from) noexcept
    : SerializedArticle() {
    *this = ::std::move(from);
  }

  inline SerializedArticle& operator=(const SerializedArticle& from) {
    CopyFrom(from);
    return *this;
  }
  inline SerializedArticle& operator=(SerializedArticle&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SerializedArticle& default_instance() {
    return *internal_default_instance();
  }
  static inline const SerializedArticle* internal_default_instance() {
    return reinterpret_cast<const SerializedArticle*>(
               &_SerializedArticle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SerializedArticle& a, SerializedArticle& b) {
    a.Swap(&b);
  }
  inline void Swap(SerializedArticle* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SerializedArticle* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SerializedArticle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SerializedArticle>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SerializedArticle& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SerializedArticle& from) {
    SerializedArticle::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SerializedArticle* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "np2ps.SerializedArticle";
  }
  protected:
  explicit SerializedArticle(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathToArticleFileFieldNumber = 2,
    kNotesFieldNumber = 4,
    kArticleFieldNumber = 1,
    kArticlePresentFieldNumber = 3,
  };
  // string path_to_article_file = 2;
  void clear_path_to_article_file();
  const std::string& path_to_article_file() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path_to_article_file(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path_to_article_file();
  PROTOBUF_NODISCARD std::string* release_path_to_article_file();
  void set_allocated_path_to_article_file(std::string* path_to_article_file);
  private:
  const std::string& _internal_path_to_article_file() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path_to_article_file(const std::string& value);
  std::string* _internal_mutable_path_to_article_file();
  public:

  // string notes = 4;
  void clear_notes();
  const std::string& notes() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_notes(ArgT0&& arg0, ArgT... args);
  std::string* mutable_notes();
  PROTOBUF_NODISCARD std::string* release_notes();
  void set_allocated_notes(std::string* notes);
  private:
  const std::string& _internal_notes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_notes(const std::string& value);
  std::string* _internal_mutable_notes();
  public:

  // .np2ps.Article article = 1;
  bool has_article() const;
  private:
  bool _internal_has_article() const;
  public:
  void clear_article();
  const ::np2ps::Article& article() const;
  PROTOBUF_NODISCARD ::np2ps::Article* release_article();
  ::np2ps::Article* mutable_article();
  void set_allocated_article(::np2ps::Article* article);
  private:
  const ::np2ps::Article& _internal_article() const;
  ::np2ps::Article* _internal_mutable_article();
  public:
  void unsafe_arena_set_allocated_article(
      ::np2ps::Article* article);
  ::np2ps::Article* unsafe_arena_release_article();

  // bool article_present = 3;
  void clear_article_present();
  bool article_present() const;
  void set_article_present(bool value);
  private:
  bool _internal_article_present() const;
  void _internal_set_article_present(bool value);
  public:

  // @@protoc_insertion_point(class_scope:np2ps.SerializedArticle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_to_article_file_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr notes_;
    ::np2ps::Article* article_;
    bool article_present_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_articles_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// HashWrapper

// uint64 hash = 1;
inline void HashWrapper::clear_hash() {
  _impl_.hash_ = uint64_t{0u};
}
inline uint64_t HashWrapper::_internal_hash() const {
  return _impl_.hash_;
}
inline uint64_t HashWrapper::hash() const {
  // @@protoc_insertion_point(field_get:np2ps.HashWrapper.hash)
  return _internal_hash();
}
inline void HashWrapper::_internal_set_hash(uint64_t value) {
  
  _impl_.hash_ = value;
}
inline void HashWrapper::set_hash(uint64_t value) {
  _internal_set_hash(value);
  // @@protoc_insertion_point(field_set:np2ps.HashWrapper.hash)
}

// uint32 level = 2;
inline void HashWrapper::clear_level() {
  _impl_.level_ = 0u;
}
inline uint32_t HashWrapper::_internal_level() const {
  return _impl_.level_;
}
inline uint32_t HashWrapper::level() const {
  // @@protoc_insertion_point(field_get:np2ps.HashWrapper.level)
  return _internal_level();
}
inline void HashWrapper::_internal_set_level(uint32_t value) {
  
  _impl_.level_ = value;
}
inline void HashWrapper::set_level(uint32_t value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:np2ps.HashWrapper.level)
}

// -------------------------------------------------------------------

// Margin

// uint64 id = 3;
inline void Margin::clear_id() {
  _impl_.id_ = uint64_t{0u};
}
inline uint64_t Margin::_internal_id() const {
  return _impl_.id_;
}
inline uint64_t Margin::id() const {
  // @@protoc_insertion_point(field_get:np2ps.Margin.id)
  return _internal_id();
}
inline void Margin::_internal_set_id(uint64_t value) {
  
  _impl_.id_ = value;
}
inline void Margin::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:np2ps.Margin.id)
}

// string type = 1;
inline void Margin::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& Margin::type() const {
  // @@protoc_insertion_point(field_get:np2ps.Margin.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Margin::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:np2ps.Margin.type)
}
inline std::string* Margin::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:np2ps.Margin.type)
  return _s;
}
inline const std::string& Margin::_internal_type() const {
  return _impl_.type_.Get();
}
inline void Margin::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* Margin::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* Margin::release_type() {
  // @@protoc_insertion_point(field_release:np2ps.Margin.type)
  return _impl_.type_.Release();
}
inline void Margin::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:np2ps.Margin.type)
}

// string content = 2;
inline void Margin::clear_content() {
  _impl_.content_.ClearToEmpty();
}
inline const std::string& Margin::content() const {
  // @@protoc_insertion_point(field_get:np2ps.Margin.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Margin::set_content(ArgT0&& arg0, ArgT... args) {
 
 _impl_.content_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:np2ps.Margin.content)
}
inline std::string* Margin::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:np2ps.Margin.content)
  return _s;
}
inline const std::string& Margin::_internal_content() const {
  return _impl_.content_.Get();
}
inline void Margin::_internal_set_content(const std::string& value) {
  
  _impl_.content_.Set(value, GetArenaForAllocation());
}
inline std::string* Margin::_internal_mutable_content() {
  
  return _impl_.content_.Mutable(GetArenaForAllocation());
}
inline std::string* Margin::release_content() {
  // @@protoc_insertion_point(field_release:np2ps.Margin.content)
  return _impl_.content_.Release();
}
inline void Margin::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  _impl_.content_.SetAllocated(content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_.IsDefault()) {
    _impl_.content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:np2ps.Margin.content)
}

// -------------------------------------------------------------------

// Margins

// repeated .np2ps.Margin margins = 1;
inline int Margins::_internal_margins_size() const {
  return _impl_.margins_.size();
}
inline int Margins::margins_size() const {
  return _internal_margins_size();
}
inline void Margins::clear_margins() {
  _impl_.margins_.Clear();
}
inline ::np2ps::Margin* Margins::mutable_margins(int index) {
  // @@protoc_insertion_point(field_mutable:np2ps.Margins.margins)
  return _impl_.margins_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::np2ps::Margin >*
Margins::mutable_margins() {
  // @@protoc_insertion_point(field_mutable_list:np2ps.Margins.margins)
  return &_impl_.margins_;
}
inline const ::np2ps::Margin& Margins::_internal_margins(int index) const {
  return _impl_.margins_.Get(index);
}
inline const ::np2ps::Margin& Margins::margins(int index) const {
  // @@protoc_insertion_point(field_get:np2ps.Margins.margins)
  return _internal_margins(index);
}
inline ::np2ps::Margin* Margins::_internal_add_margins() {
  return _impl_.margins_.Add();
}
inline ::np2ps::Margin* Margins::add_margins() {
  ::np2ps::Margin* _add = _internal_add_margins();
  // @@protoc_insertion_point(field_add:np2ps.Margins.margins)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::np2ps::Margin >&
Margins::margins() const {
  // @@protoc_insertion_point(field_list:np2ps.Margins.margins)
  return _impl_.margins_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Article

// optional string author_name = 1;
inline bool Article::_internal_has_author_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Article::has_author_name() const {
  return _internal_has_author_name();
}
inline void Article::clear_author_name() {
  _impl_.author_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Article::author_name() const {
  // @@protoc_insertion_point(field_get:np2ps.Article.author_name)
  return _internal_author_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Article::set_author_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.author_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:np2ps.Article.author_name)
}
inline std::string* Article::mutable_author_name() {
  std::string* _s = _internal_mutable_author_name();
  // @@protoc_insertion_point(field_mutable:np2ps.Article.author_name)
  return _s;
}
inline const std::string& Article::_internal_author_name() const {
  return _impl_.author_name_.Get();
}
inline void Article::_internal_set_author_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.author_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Article::_internal_mutable_author_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.author_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Article::release_author_name() {
  // @@protoc_insertion_point(field_release:np2ps.Article.author_name)
  if (!_internal_has_author_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.author_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.author_name_.IsDefault()) {
    _impl_.author_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Article::set_allocated_author_name(std::string* author_name) {
  if (author_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.author_name_.SetAllocated(author_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.author_name_.IsDefault()) {
    _impl_.author_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:np2ps.Article.author_name)
}

// uint64 author_id = 2;
inline void Article::clear_author_id() {
  _impl_.author_id_ = uint64_t{0u};
}
inline uint64_t Article::_internal_author_id() const {
  return _impl_.author_id_;
}
inline uint64_t Article::author_id() const {
  // @@protoc_insertion_point(field_get:np2ps.Article.author_id)
  return _internal_author_id();
}
inline void Article::_internal_set_author_id(uint64_t value) {
  
  _impl_.author_id_ = value;
}
inline void Article::set_author_id(uint64_t value) {
  _internal_set_author_id(value);
  // @@protoc_insertion_point(field_set:np2ps.Article.author_id)
}

// optional string news_name = 3;
inline bool Article::_internal_has_news_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Article::has_news_name() const {
  return _internal_has_news_name();
}
inline void Article::clear_news_name() {
  _impl_.news_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Article::news_name() const {
  // @@protoc_insertion_point(field_get:np2ps.Article.news_name)
  return _internal_news_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Article::set_news_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.news_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:np2ps.Article.news_name)
}
inline std::string* Article::mutable_news_name() {
  std::string* _s = _internal_mutable_news_name();
  // @@protoc_insertion_point(field_mutable:np2ps.Article.news_name)
  return _s;
}
inline const std::string& Article::_internal_news_name() const {
  return _impl_.news_name_.Get();
}
inline void Article::_internal_set_news_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.news_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Article::_internal_mutable_news_name() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.news_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Article::release_news_name() {
  // @@protoc_insertion_point(field_release:np2ps.Article.news_name)
  if (!_internal_has_news_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.news_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.news_name_.IsDefault()) {
    _impl_.news_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Article::set_allocated_news_name(std::string* news_name) {
  if (news_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.news_name_.SetAllocated(news_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.news_name_.IsDefault()) {
    _impl_.news_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:np2ps.Article.news_name)
}

// uint64 news_id = 4;
inline void Article::clear_news_id() {
  _impl_.news_id_ = uint64_t{0u};
}
inline uint64_t Article::_internal_news_id() const {
  return _impl_.news_id_;
}
inline uint64_t Article::news_id() const {
  // @@protoc_insertion_point(field_get:np2ps.Article.news_id)
  return _internal_news_id();
}
inline void Article::_internal_set_news_id(uint64_t value) {
  
  _impl_.news_id_ = value;
}
inline void Article::set_news_id(uint64_t value) {
  _internal_set_news_id(value);
  // @@protoc_insertion_point(field_set:np2ps.Article.news_id)
}

// uint64 main_hash = 5;
inline void Article::clear_main_hash() {
  _impl_.main_hash_ = uint64_t{0u};
}
inline uint64_t Article::_internal_main_hash() const {
  return _impl_.main_hash_;
}
inline uint64_t Article::main_hash() const {
  // @@protoc_insertion_point(field_get:np2ps.Article.main_hash)
  return _internal_main_hash();
}
inline void Article::_internal_set_main_hash(uint64_t value) {
  
  _impl_.main_hash_ = value;
}
inline void Article::set_main_hash(uint64_t value) {
  _internal_set_main_hash(value);
  // @@protoc_insertion_point(field_set:np2ps.Article.main_hash)
}

// string heading = 6;
inline void Article::clear_heading() {
  _impl_.heading_.ClearToEmpty();
}
inline const std::string& Article::heading() const {
  // @@protoc_insertion_point(field_get:np2ps.Article.heading)
  return _internal_heading();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Article::set_heading(ArgT0&& arg0, ArgT... args) {
 
 _impl_.heading_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:np2ps.Article.heading)
}
inline std::string* Article::mutable_heading() {
  std::string* _s = _internal_mutable_heading();
  // @@protoc_insertion_point(field_mutable:np2ps.Article.heading)
  return _s;
}
inline const std::string& Article::_internal_heading() const {
  return _impl_.heading_.Get();
}
inline void Article::_internal_set_heading(const std::string& value) {
  
  _impl_.heading_.Set(value, GetArenaForAllocation());
}
inline std::string* Article::_internal_mutable_heading() {
  
  return _impl_.heading_.Mutable(GetArenaForAllocation());
}
inline std::string* Article::release_heading() {
  // @@protoc_insertion_point(field_release:np2ps.Article.heading)
  return _impl_.heading_.Release();
}
inline void Article::set_allocated_heading(std::string* heading) {
  if (heading != nullptr) {
    
  } else {
    
  }
  _impl_.heading_.SetAllocated(heading, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.heading_.IsDefault()) {
    _impl_.heading_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:np2ps.Article.heading)
}

// map<int32, .np2ps.HashWrapper> paragraph_hashes = 7;
inline int Article::_internal_paragraph_hashes_size() const {
  return _impl_.paragraph_hashes_.size();
}
inline int Article::paragraph_hashes_size() const {
  return _internal_paragraph_hashes_size();
}
inline void Article::clear_paragraph_hashes() {
  _impl_.paragraph_hashes_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::np2ps::HashWrapper >&
Article::_internal_paragraph_hashes() const {
  return _impl_.paragraph_hashes_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::np2ps::HashWrapper >&
Article::paragraph_hashes() const {
  // @@protoc_insertion_point(field_map:np2ps.Article.paragraph_hashes)
  return _internal_paragraph_hashes();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::np2ps::HashWrapper >*
Article::_internal_mutable_paragraph_hashes() {
  return _impl_.paragraph_hashes_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::np2ps::HashWrapper >*
Article::mutable_paragraph_hashes() {
  // @@protoc_insertion_point(field_mutable_map:np2ps.Article.paragraph_hashes)
  return _internal_mutable_paragraph_hashes();
}

// uint64 length = 8;
inline void Article::clear_length() {
  _impl_.length_ = uint64_t{0u};
}
inline uint64_t Article::_internal_length() const {
  return _impl_.length_;
}
inline uint64_t Article::length() const {
  // @@protoc_insertion_point(field_get:np2ps.Article.length)
  return _internal_length();
}
inline void Article::_internal_set_length(uint64_t value) {
  
  _impl_.length_ = value;
}
inline void Article::set_length(uint64_t value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:np2ps.Article.length)
}

// repeated string categories = 9;
inline int Article::_internal_categories_size() const {
  return _impl_.categories_.size();
}
inline int Article::categories_size() const {
  return _internal_categories_size();
}
inline void Article::clear_categories() {
  _impl_.categories_.Clear();
}
inline std::string* Article::add_categories() {
  std::string* _s = _internal_add_categories();
  // @@protoc_insertion_point(field_add_mutable:np2ps.Article.categories)
  return _s;
}
inline const std::string& Article::_internal_categories(int index) const {
  return _impl_.categories_.Get(index);
}
inline const std::string& Article::categories(int index) const {
  // @@protoc_insertion_point(field_get:np2ps.Article.categories)
  return _internal_categories(index);
}
inline std::string* Article::mutable_categories(int index) {
  // @@protoc_insertion_point(field_mutable:np2ps.Article.categories)
  return _impl_.categories_.Mutable(index);
}
inline void Article::set_categories(int index, const std::string& value) {
  _impl_.categories_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:np2ps.Article.categories)
}
inline void Article::set_categories(int index, std::string&& value) {
  _impl_.categories_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:np2ps.Article.categories)
}
inline void Article::set_categories(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.categories_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:np2ps.Article.categories)
}
inline void Article::set_categories(int index, const char* value, size_t size) {
  _impl_.categories_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:np2ps.Article.categories)
}
inline std::string* Article::_internal_add_categories() {
  return _impl_.categories_.Add();
}
inline void Article::add_categories(const std::string& value) {
  _impl_.categories_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:np2ps.Article.categories)
}
inline void Article::add_categories(std::string&& value) {
  _impl_.categories_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:np2ps.Article.categories)
}
inline void Article::add_categories(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.categories_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:np2ps.Article.categories)
}
inline void Article::add_categories(const char* value, size_t size) {
  _impl_.categories_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:np2ps.Article.categories)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Article::categories() const {
  // @@protoc_insertion_point(field_list:np2ps.Article.categories)
  return _impl_.categories_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Article::mutable_categories() {
  // @@protoc_insertion_point(field_mutable_list:np2ps.Article.categories)
  return &_impl_.categories_;
}

// map<uint64, .np2ps.Margins> margins = 10;
inline int Article::_internal_margins_size() const {
  return _impl_.margins_.size();
}
inline int Article::margins_size() const {
  return _internal_margins_size();
}
inline void Article::clear_margins() {
  _impl_.margins_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::np2ps::Margins >&
Article::_internal_margins() const {
  return _impl_.margins_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::np2ps::Margins >&
Article::margins() const {
  // @@protoc_insertion_point(field_map:np2ps.Article.margins)
  return _internal_margins();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::np2ps::Margins >*
Article::_internal_mutable_margins() {
  return _impl_.margins_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::np2ps::Margins >*
Article::mutable_margins() {
  // @@protoc_insertion_point(field_mutable_map:np2ps.Article.margins)
  return _internal_mutable_margins();
}

// uint32 type = 11;
inline void Article::clear_type() {
  _impl_.type_ = 0u;
}
inline uint32_t Article::_internal_type() const {
  return _impl_.type_;
}
inline uint32_t Article::type() const {
  // @@protoc_insertion_point(field_get:np2ps.Article.type)
  return _internal_type();
}
inline void Article::_internal_set_type(uint32_t value) {
  
  _impl_.type_ = value;
}
inline void Article::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:np2ps.Article.type)
}

// bytes crypto_hash = 12;
inline void Article::clear_crypto_hash() {
  _impl_.crypto_hash_.ClearToEmpty();
}
inline const std::string& Article::crypto_hash() const {
  // @@protoc_insertion_point(field_get:np2ps.Article.crypto_hash)
  return _internal_crypto_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Article::set_crypto_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.crypto_hash_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:np2ps.Article.crypto_hash)
}
inline std::string* Article::mutable_crypto_hash() {
  std::string* _s = _internal_mutable_crypto_hash();
  // @@protoc_insertion_point(field_mutable:np2ps.Article.crypto_hash)
  return _s;
}
inline const std::string& Article::_internal_crypto_hash() const {
  return _impl_.crypto_hash_.Get();
}
inline void Article::_internal_set_crypto_hash(const std::string& value) {
  
  _impl_.crypto_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* Article::_internal_mutable_crypto_hash() {
  
  return _impl_.crypto_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* Article::release_crypto_hash() {
  // @@protoc_insertion_point(field_release:np2ps.Article.crypto_hash)
  return _impl_.crypto_hash_.Release();
}
inline void Article::set_allocated_crypto_hash(std::string* crypto_hash) {
  if (crypto_hash != nullptr) {
    
  } else {
    
  }
  _impl_.crypto_hash_.SetAllocated(crypto_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.crypto_hash_.IsDefault()) {
    _impl_.crypto_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:np2ps.Article.crypto_hash)
}

// int64 creation_time = 13;
inline void Article::clear_creation_time() {
  _impl_.creation_time_ = int64_t{0};
}
inline int64_t Article::_internal_creation_time() const {
  return _impl_.creation_time_;
}
inline int64_t Article::creation_time() const {
  // @@protoc_insertion_point(field_get:np2ps.Article.creation_time)
  return _internal_creation_time();
}
inline void Article::_internal_set_creation_time(int64_t value) {
  
  _impl_.creation_time_ = value;
}
inline void Article::set_creation_time(int64_t value) {
  _internal_set_creation_time(value);
  // @@protoc_insertion_point(field_set:np2ps.Article.creation_time)
}

// int64 modification_time = 14;
inline void Article::clear_modification_time() {
  _impl_.modification_time_ = int64_t{0};
}
inline int64_t Article::_internal_modification_time() const {
  return _impl_.modification_time_;
}
inline int64_t Article::modification_time() const {
  // @@protoc_insertion_point(field_get:np2ps.Article.modification_time)
  return _internal_modification_time();
}
inline void Article::_internal_set_modification_time(int64_t value) {
  
  _impl_.modification_time_ = value;
}
inline void Article::set_modification_time(int64_t value) {
  _internal_set_modification_time(value);
  // @@protoc_insertion_point(field_set:np2ps.Article.modification_time)
}

// -------------------------------------------------------------------

// SerializedArticle

// .np2ps.Article article = 1;
inline bool SerializedArticle::_internal_has_article() const {
  return this != internal_default_instance() && _impl_.article_ != nullptr;
}
inline bool SerializedArticle::has_article() const {
  return _internal_has_article();
}
inline void SerializedArticle::clear_article() {
  if (GetArenaForAllocation() == nullptr && _impl_.article_ != nullptr) {
    delete _impl_.article_;
  }
  _impl_.article_ = nullptr;
}
inline const ::np2ps::Article& SerializedArticle::_internal_article() const {
  const ::np2ps::Article* p = _impl_.article_;
  return p != nullptr ? *p : reinterpret_cast<const ::np2ps::Article&>(
      ::np2ps::_Article_default_instance_);
}
inline const ::np2ps::Article& SerializedArticle::article() const {
  // @@protoc_insertion_point(field_get:np2ps.SerializedArticle.article)
  return _internal_article();
}
inline void SerializedArticle::unsafe_arena_set_allocated_article(
    ::np2ps::Article* article) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.article_);
  }
  _impl_.article_ = article;
  if (article) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:np2ps.SerializedArticle.article)
}
inline ::np2ps::Article* SerializedArticle::release_article() {
  
  ::np2ps::Article* temp = _impl_.article_;
  _impl_.article_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::np2ps::Article* SerializedArticle::unsafe_arena_release_article() {
  // @@protoc_insertion_point(field_release:np2ps.SerializedArticle.article)
  
  ::np2ps::Article* temp = _impl_.article_;
  _impl_.article_ = nullptr;
  return temp;
}
inline ::np2ps::Article* SerializedArticle::_internal_mutable_article() {
  
  if (_impl_.article_ == nullptr) {
    auto* p = CreateMaybeMessage<::np2ps::Article>(GetArenaForAllocation());
    _impl_.article_ = p;
  }
  return _impl_.article_;
}
inline ::np2ps::Article* SerializedArticle::mutable_article() {
  ::np2ps::Article* _msg = _internal_mutable_article();
  // @@protoc_insertion_point(field_mutable:np2ps.SerializedArticle.article)
  return _msg;
}
inline void SerializedArticle::set_allocated_article(::np2ps::Article* article) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.article_;
  }
  if (article) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(article);
    if (message_arena != submessage_arena) {
      article = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, article, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.article_ = article;
  // @@protoc_insertion_point(field_set_allocated:np2ps.SerializedArticle.article)
}

// string path_to_article_file = 2;
inline void SerializedArticle::clear_path_to_article_file() {
  _impl_.path_to_article_file_.ClearToEmpty();
}
inline const std::string& SerializedArticle::path_to_article_file() const {
  // @@protoc_insertion_point(field_get:np2ps.SerializedArticle.path_to_article_file)
  return _internal_path_to_article_file();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SerializedArticle::set_path_to_article_file(ArgT0&& arg0, ArgT... args) {
 
 _impl_.path_to_article_file_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:np2ps.SerializedArticle.path_to_article_file)
}
inline std::string* SerializedArticle::mutable_path_to_article_file() {
  std::string* _s = _internal_mutable_path_to_article_file();
  // @@protoc_insertion_point(field_mutable:np2ps.SerializedArticle.path_to_article_file)
  return _s;
}
inline const std::string& SerializedArticle::_internal_path_to_article_file() const {
  return _impl_.path_to_article_file_.Get();
}
inline void SerializedArticle::_internal_set_path_to_article_file(const std::string& value) {
  
  _impl_.path_to_article_file_.Set(value, GetArenaForAllocation());
}
inline std::string* SerializedArticle::_internal_mutable_path_to_article_file() {
  
  return _impl_.path_to_article_file_.Mutable(GetArenaForAllocation());
}
inline std::string* SerializedArticle::release_path_to_article_file() {
  // @@protoc_insertion_point(field_release:np2ps.SerializedArticle.path_to_article_file)
  return _impl_.path_to_article_file_.Release();
}
inline void SerializedArticle::set_allocated_path_to_article_file(std::string* path_to_article_file) {
  if (path_to_article_file != nullptr) {
    
  } else {
    
  }
  _impl_.path_to_article_file_.SetAllocated(path_to_article_file, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_to_article_file_.IsDefault()) {
    _impl_.path_to_article_file_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:np2ps.SerializedArticle.path_to_article_file)
}

// bool article_present = 3;
inline void SerializedArticle::clear_article_present() {
  _impl_.article_present_ = false;
}
inline bool SerializedArticle::_internal_article_present() const {
  return _impl_.article_present_;
}
inline bool SerializedArticle::article_present() const {
  // @@protoc_insertion_point(field_get:np2ps.SerializedArticle.article_present)
  return _internal_article_present();
}
inline void SerializedArticle::_internal_set_article_present(bool value) {
  
  _impl_.article_present_ = value;
}
inline void SerializedArticle::set_article_present(bool value) {
  _internal_set_article_present(value);
  // @@protoc_insertion_point(field_set:np2ps.SerializedArticle.article_present)
}

// string notes = 4;
inline void SerializedArticle::clear_notes() {
  _impl_.notes_.ClearToEmpty();
}
inline const std::string& SerializedArticle::notes() const {
  // @@protoc_insertion_point(field_get:np2ps.SerializedArticle.notes)
  return _internal_notes();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SerializedArticle::set_notes(ArgT0&& arg0, ArgT... args) {
 
 _impl_.notes_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:np2ps.SerializedArticle.notes)
}
inline std::string* SerializedArticle::mutable_notes() {
  std::string* _s = _internal_mutable_notes();
  // @@protoc_insertion_point(field_mutable:np2ps.SerializedArticle.notes)
  return _s;
}
inline const std::string& SerializedArticle::_internal_notes() const {
  return _impl_.notes_.Get();
}
inline void SerializedArticle::_internal_set_notes(const std::string& value) {
  
  _impl_.notes_.Set(value, GetArenaForAllocation());
}
inline std::string* SerializedArticle::_internal_mutable_notes() {
  
  return _impl_.notes_.Mutable(GetArenaForAllocation());
}
inline std::string* SerializedArticle::release_notes() {
  // @@protoc_insertion_point(field_release:np2ps.SerializedArticle.notes)
  return _impl_.notes_.Release();
}
inline void SerializedArticle::set_allocated_notes(std::string* notes) {
  if (notes != nullptr) {
    
  } else {
    
  }
  _impl_.notes_.SetAllocated(notes, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.notes_.IsDefault()) {
    _impl_.notes_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:np2ps.SerializedArticle.notes)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace np2ps

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_articles_2eproto
