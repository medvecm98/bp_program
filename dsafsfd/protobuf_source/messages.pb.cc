// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages.proto

#include "messages.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace np2ps {
PROTOBUF_CONSTEXPR Message::Message(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.from_)*/uint64_t{0u}
  , /*decltype(_impl_.to_)*/uint64_t{0u}
  , /*decltype(_impl_.msg_type_)*/0
  , /*decltype(_impl_.msg_ctx_)*/0
  , /*decltype(_impl_.seq_)*/uint64_t{0u}
  , /*decltype(_impl_.message_oneof_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct MessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MessageDefaultTypeInternal() {}
  union {
    Message _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MessageDefaultTypeInternal _Message_default_instance_;
PROTOBUF_CONSTEXPR ArticleAll::ArticleAll(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.article_actual_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.article_hash_)*/uint64_t{0u}
  , /*decltype(_impl_.level_)*/0u} {}
struct ArticleAllDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ArticleAllDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ArticleAllDefaultTypeInternal() {}
  union {
    ArticleAll _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ArticleAllDefaultTypeInternal _ArticleAll_default_instance_;
PROTOBUF_CONSTEXPR ArticleHeader::ArticleHeader(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.article_)*/nullptr
  , /*decltype(_impl_.article_hash_)*/uint64_t{0u}} {}
struct ArticleHeaderDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ArticleHeaderDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ArticleHeaderDefaultTypeInternal() {}
  union {
    ArticleHeader _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ArticleHeaderDefaultTypeInternal _ArticleHeader_default_instance_;
PROTOBUF_CONSTEXPR ArticleList::ArticleList(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.categories_)*/{}
  , /*decltype(_impl_.response_)*/{}
  , /*decltype(_impl_.all_articles_)*/false
  , /*decltype(_impl_.count_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ArticleListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ArticleListDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ArticleListDefaultTypeInternal() {}
  union {
    ArticleList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ArticleListDefaultTypeInternal _ArticleList_default_instance_;
PROTOBUF_CONSTEXPR ArticleSolicitation::ArticleSolicitation(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.possible_owners_)*/{}
  , /*decltype(_impl_._possible_owners_cached_byte_size_)*/{0}
  , /*decltype(_impl_.article_hash_)*/uint64_t{0u}
  , /*decltype(_impl_.level_)*/0u} {}
struct ArticleSolicitationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ArticleSolicitationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ArticleSolicitationDefaultTypeInternal() {}
  union {
    ArticleSolicitation _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ArticleSolicitationDefaultTypeInternal _ArticleSolicitation_default_instance_;
PROTOBUF_CONSTEXPR UserIsMember::UserIsMember(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.user_pk_)*/uint64_t{0u}
  , /*decltype(_impl_.level_)*/0u
  , /*decltype(_impl_.is_member_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UserIsMemberDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UserIsMemberDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UserIsMemberDefaultTypeInternal() {}
  union {
    UserIsMember _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserIsMemberDefaultTypeInternal _UserIsMember_default_instance_;
PROTOBUF_CONSTEXPR ArticleDataUpdate::ArticleDataUpdate(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.article_pk_)*/uint64_t{0u}
  , /*decltype(_impl_.article_action_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ArticleDataUpdateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ArticleDataUpdateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ArticleDataUpdateDefaultTypeInternal() {}
  union {
    ArticleDataUpdate _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ArticleDataUpdateDefaultTypeInternal _ArticleDataUpdate_default_instance_;
PROTOBUF_CONSTEXPR UpdateMargin::UpdateMargin(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.margin_)*/nullptr
  , /*decltype(_impl_.article_pk_)*/uint64_t{0u}
  , /*decltype(_impl_.m_action_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UpdateMarginDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UpdateMarginDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UpdateMarginDefaultTypeInternal() {}
  union {
    UpdateMargin _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UpdateMarginDefaultTypeInternal _UpdateMargin_default_instance_;
PROTOBUF_CONSTEXPR UpdateArticle::UpdateArticle(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.article_pk_)*/uint64_t{0u}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UpdateArticleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UpdateArticleDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UpdateArticleDefaultTypeInternal() {}
  union {
    UpdateArticle _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UpdateArticleDefaultTypeInternal _UpdateArticle_default_instance_;
PROTOBUF_CONSTEXPR Credentials::Credentials(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ipv4_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.ipv6_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.rsa_public_key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.eax_key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.req_ipv4_)*/false
  , /*decltype(_impl_.req_ipv6_)*/false
  , /*decltype(_impl_.req_rsa_public_key_)*/false
  , /*decltype(_impl_.req_eax_key_)*/false} {}
struct CredentialsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CredentialsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CredentialsDefaultTypeInternal() {}
  union {
    Credentials _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CredentialsDefaultTypeInternal _Credentials_default_instance_;
PROTOBUF_CONSTEXPR SymmetricKey::SymmetricKey(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.signature_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SymmetricKeyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SymmetricKeyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SymmetricKeyDefaultTypeInternal() {}
  union {
    SymmetricKey _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SymmetricKeyDefaultTypeInternal _SymmetricKey_default_instance_;
PROTOBUF_CONSTEXPR PublicKey::PublicKey(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PublicKeyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PublicKeyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PublicKeyDefaultTypeInternal() {}
  union {
    PublicKey _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PublicKeyDefaultTypeInternal _PublicKey_default_instance_;
}  // namespace np2ps
static ::_pb::Metadata file_level_metadata_messages_2eproto[12];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_messages_2eproto[4];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_messages_2eproto = nullptr;

const uint32_t TableStruct_messages_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::np2ps::Message, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::np2ps::Message, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::np2ps::Message, _impl_.from_),
  PROTOBUF_FIELD_OFFSET(::np2ps::Message, _impl_.to_),
  PROTOBUF_FIELD_OFFSET(::np2ps::Message, _impl_.seq_),
  PROTOBUF_FIELD_OFFSET(::np2ps::Message, _impl_.msg_type_),
  PROTOBUF_FIELD_OFFSET(::np2ps::Message, _impl_.msg_ctx_),
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::np2ps::Message, _impl_.message_oneof_),
  PROTOBUF_FIELD_OFFSET(::np2ps::ArticleAll, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::np2ps::ArticleAll, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::np2ps::ArticleAll, _impl_.article_hash_),
  PROTOBUF_FIELD_OFFSET(::np2ps::ArticleAll, _impl_.level_),
  PROTOBUF_FIELD_OFFSET(::np2ps::ArticleAll, _impl_.header_),
  PROTOBUF_FIELD_OFFSET(::np2ps::ArticleAll, _impl_.article_actual_),
  ~0u,
  ~0u,
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::np2ps::ArticleHeader, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::np2ps::ArticleHeader, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::np2ps::ArticleHeader, _impl_.article_hash_),
  PROTOBUF_FIELD_OFFSET(::np2ps::ArticleHeader, _impl_.article_),
  ~0u,
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::np2ps::ArticleList, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::np2ps::ArticleList, _impl_.all_articles_),
  PROTOBUF_FIELD_OFFSET(::np2ps::ArticleList, _impl_.categories_),
  PROTOBUF_FIELD_OFFSET(::np2ps::ArticleList, _impl_.count_),
  PROTOBUF_FIELD_OFFSET(::np2ps::ArticleList, _impl_.response_),
  PROTOBUF_FIELD_OFFSET(::np2ps::ArticleSolicitation, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::np2ps::ArticleSolicitation, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::np2ps::ArticleSolicitation, _impl_.article_hash_),
  PROTOBUF_FIELD_OFFSET(::np2ps::ArticleSolicitation, _impl_.possible_owners_),
  PROTOBUF_FIELD_OFFSET(::np2ps::ArticleSolicitation, _impl_.level_),
  ~0u,
  ~0u,
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::np2ps::UserIsMember, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::np2ps::UserIsMember, _impl_.user_pk_),
  PROTOBUF_FIELD_OFFSET(::np2ps::UserIsMember, _impl_.level_),
  PROTOBUF_FIELD_OFFSET(::np2ps::UserIsMember, _impl_.is_member_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::np2ps::ArticleDataUpdate, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::np2ps::ArticleDataUpdate, _impl_.article_pk_),
  PROTOBUF_FIELD_OFFSET(::np2ps::ArticleDataUpdate, _impl_.article_action_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::np2ps::UpdateMargin, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::np2ps::UpdateMargin, _impl_.article_pk_),
  PROTOBUF_FIELD_OFFSET(::np2ps::UpdateMargin, _impl_.m_action_),
  PROTOBUF_FIELD_OFFSET(::np2ps::UpdateMargin, _impl_.margin_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::np2ps::UpdateArticle, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::np2ps::UpdateArticle, _impl_.article_pk_),
  PROTOBUF_FIELD_OFFSET(::np2ps::Credentials, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::np2ps::Credentials, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::np2ps::Credentials, _impl_.req_ipv4_),
  PROTOBUF_FIELD_OFFSET(::np2ps::Credentials, _impl_.req_ipv6_),
  PROTOBUF_FIELD_OFFSET(::np2ps::Credentials, _impl_.req_rsa_public_key_),
  PROTOBUF_FIELD_OFFSET(::np2ps::Credentials, _impl_.req_eax_key_),
  PROTOBUF_FIELD_OFFSET(::np2ps::Credentials, _impl_.ipv4_),
  PROTOBUF_FIELD_OFFSET(::np2ps::Credentials, _impl_.ipv6_),
  PROTOBUF_FIELD_OFFSET(::np2ps::Credentials, _impl_.rsa_public_key_),
  PROTOBUF_FIELD_OFFSET(::np2ps::Credentials, _impl_.eax_key_),
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  0,
  1,
  2,
  3,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::np2ps::SymmetricKey, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::np2ps::SymmetricKey, _impl_.key_),
  PROTOBUF_FIELD_OFFSET(::np2ps::SymmetricKey, _impl_.signature_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::np2ps::PublicKey, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::np2ps::PublicKey, _impl_.key_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::np2ps::Message)},
  { 23, 33, -1, sizeof(::np2ps::ArticleAll)},
  { 37, 45, -1, sizeof(::np2ps::ArticleHeader)},
  { 47, -1, -1, sizeof(::np2ps::ArticleList)},
  { 57, 66, -1, sizeof(::np2ps::ArticleSolicitation)},
  { 69, -1, -1, sizeof(::np2ps::UserIsMember)},
  { 78, -1, -1, sizeof(::np2ps::ArticleDataUpdate)},
  { 86, -1, -1, sizeof(::np2ps::UpdateMargin)},
  { 95, -1, -1, sizeof(::np2ps::UpdateArticle)},
  { 102, 116, -1, sizeof(::np2ps::Credentials)},
  { 124, -1, -1, sizeof(::np2ps::SymmetricKey)},
  { 132, -1, -1, sizeof(::np2ps::PublicKey)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::np2ps::_Message_default_instance_._instance,
  &::np2ps::_ArticleAll_default_instance_._instance,
  &::np2ps::_ArticleHeader_default_instance_._instance,
  &::np2ps::_ArticleList_default_instance_._instance,
  &::np2ps::_ArticleSolicitation_default_instance_._instance,
  &::np2ps::_UserIsMember_default_instance_._instance,
  &::np2ps::_ArticleDataUpdate_default_instance_._instance,
  &::np2ps::_UpdateMargin_default_instance_._instance,
  &::np2ps::_UpdateArticle_default_instance_._instance,
  &::np2ps::_Credentials_default_instance_._instance,
  &::np2ps::_SymmetricKey_default_instance_._instance,
  &::np2ps::_PublicKey_default_instance_._instance,
};

const char descriptor_table_protodef_messages_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\016messages.proto\022\005np2ps\032\016articles.proto\""
  "\226\005\n\007Message\022\014\n\004from\030\001 \001(\004\022\n\n\002to\030\002 \001(\004\022\013\n"
  "\003seq\030\005 \001(\004\022$\n\010msg_type\030\003 \001(\0162\022.np2ps.Mes"
  "sageType\022&\n\007msg_ctx\030\004 \001(\0162\025.np2ps.Messag"
  "eContext\022(\n\013article_all\030n \001(\0132\021.np2ps.Ar"
  "ticleAllH\000\022.\n\016article_header\030x \001(\0132\024.np2"
  "ps.ArticleHeaderH\000\0221\n\013article_sol\030y \001(\0132"
  "\032.np2ps.ArticleSolicitationH\000\022*\n\014article"
  "_list\030} \001(\0132\022.np2ps.ArticleListH\000\022.\n\016use"
  "r_is_member\030\202\001 \001(\0132\023.np2ps.UserIsMemberH"
  "\000\0228\n\023article_data_update\030\214\001 \001(\0132\030.np2ps."
  "ArticleDataUpdateH\000\022-\n\rupdate_margin\030\252\001 "
  "\001(\0132\023.np2ps.UpdateMarginH\000\022/\n\016update_art"
  "icle\030\264\001 \001(\0132\024.np2ps.UpdateArticleH\000\022*\n\013c"
  "redentials\030\310\001 \001(\0132\022.np2ps.CredentialsH\000\022"
  "-\n\rsymmetric_key\030\322\001 \001(\0132\023.np2ps.Symmetri"
  "cKeyH\000\022\'\n\npublic_key\030\334\001 \001(\0132\020.np2ps.Publ"
  "icKeyH\000B\017\n\rmessage_oneof\"\221\001\n\nArticleAll\022"
  "\024\n\014article_hash\030\001 \001(\004\022\r\n\005level\030\002 \001(\r\022#\n\006"
  "header\030\003 \001(\0132\016.np2ps.ArticleH\000\210\001\001\022\033\n\016art"
  "icle_actual\030\004 \001(\tH\001\210\001\001B\t\n\007_headerB\021\n\017_ar"
  "ticle_actual\"W\n\rArticleHeader\022\024\n\014article"
  "_hash\030\002 \001(\004\022$\n\007article\030\004 \001(\0132\016.np2ps.Art"
  "icleH\000\210\001\001B\n\n\010_article\"h\n\013ArticleList\022\024\n\014"
  "all_articles\030\001 \001(\010\022\022\n\ncategories\030\002 \003(\t\022\r"
  "\n\005count\030\004 \001(\005\022 \n\010response\030\003 \003(\0132\016.np2ps."
  "Article\"b\n\023ArticleSolicitation\022\024\n\014articl"
  "e_hash\030\001 \001(\004\022\027\n\017possible_owners\030\002 \003(\004\022\022\n"
  "\005level\030\003 \001(\rH\000\210\001\001B\010\n\006_level\"A\n\014UserIsMem"
  "ber\022\017\n\007user_pk\030\001 \001(\004\022\r\n\005level\030\002 \001(\r\022\021\n\ti"
  "s_member\030\003 \001(\010\"U\n\021ArticleDataUpdate\022\022\n\na"
  "rticle_pk\030\001 \001(\004\022,\n\016article_action\030\003 \001(\0162"
  "\024.np2ps.ArticleAction\"i\n\014UpdateMargin\022\022\n"
  "\narticle_pk\030\001 \001(\004\022%\n\010m_action\030\002 \001(\0162\023.np"
  "2ps.MarginAction\022\036\n\006margin\030\003 \001(\0132\016.np2ps"
  ".Margins\"#\n\rUpdateArticle\022\022\n\narticle_pk\030"
  "\001 \001(\004\"\354\001\n\013Credentials\022\020\n\010req_ipv4\030\005 \001(\010\022"
  "\020\n\010req_ipv6\030\006 \001(\010\022\032\n\022req_rsa_public_key\030"
  "\007 \001(\010\022\023\n\013req_eax_key\030\010 \001(\010\022\021\n\004ipv4\030\001 \001(\t"
  "H\000\210\001\001\022\021\n\004ipv6\030\002 \001(\tH\001\210\001\001\022\033\n\016rsa_public_k"
  "ey\030\003 \001(\tH\002\210\001\001\022\024\n\007eax_key\030\004 \001(\tH\003\210\001\001B\007\n\005_"
  "ipv4B\007\n\005_ipv6B\021\n\017_rsa_public_keyB\n\n\010_eax"
  "_key\".\n\014SymmetricKey\022\013\n\003key\030\001 \001(\014\022\021\n\tsig"
  "nature\030\002 \001(\014\"\030\n\tPublicKey\022\013\n\003key\030\001 \001(\014*\361"
  "\001\n\013MessageType\022\t\n\005EMPTY\020\000\022\017\n\013ARTICLE_ALL"
  "\020\n\022\022\n\016ARTICLE_HEADER\020\024\022\030\n\024ARTICLE_SOLICI"
  "TATION\020\025\022\020\n\014ARTICLE_LIST\020\031\022\022\n\016USER_IS_ME"
  "MBER\020\036\022\027\n\023ARTICLE_DATA_UPDATE\020(\022\021\n\rUPDAT"
  "E_MARGIN\020F\022\022\n\016UPDATE_ARTICLE\020Z\022\017\n\013CREDEN"
  "TIALS\020d\022\021\n\rSYMMETRIC_KEY\020n\022\016\n\nPUBLIC_KEY"
  "\020x*C\n\016MessageContext\022\t\n\005ERROR\020\000\022\013\n\007REQUE"
  "ST\020\n\022\014\n\010RESPONSE\020\024\022\013\n\007ONE_WAY\020\036*/\n\014Margi"
  "nAction\022\n\n\006REMOVE\020\000\022\007\n\003ADD\020\n\022\n\n\006UPDATE\020\024"
  "**\n\rArticleAction\022\014\n\010DOWNLOAD\020\000\022\013\n\007REMOV"
  "AL\020\nb\006proto3"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_messages_2eproto_deps[1] = {
  &::descriptor_table_articles_2eproto,
};
static ::_pbi::once_flag descriptor_table_messages_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_messages_2eproto = {
    false, false, 2172, descriptor_table_protodef_messages_2eproto,
    "messages.proto",
    &descriptor_table_messages_2eproto_once, descriptor_table_messages_2eproto_deps, 1, 12,
    schemas, file_default_instances, TableStruct_messages_2eproto::offsets,
    file_level_metadata_messages_2eproto, file_level_enum_descriptors_messages_2eproto,
    file_level_service_descriptors_messages_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_messages_2eproto_getter() {
  return &descriptor_table_messages_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_messages_2eproto(&descriptor_table_messages_2eproto);
namespace np2ps {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MessageType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_messages_2eproto);
  return file_level_enum_descriptors_messages_2eproto[0];
}
bool MessageType_IsValid(int value) {
  switch (value) {
    case 0:
    case 10:
    case 20:
    case 21:
    case 25:
    case 30:
    case 40:
    case 70:
    case 90:
    case 100:
    case 110:
    case 120:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MessageContext_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_messages_2eproto);
  return file_level_enum_descriptors_messages_2eproto[1];
}
bool MessageContext_IsValid(int value) {
  switch (value) {
    case 0:
    case 10:
    case 20:
    case 30:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MarginAction_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_messages_2eproto);
  return file_level_enum_descriptors_messages_2eproto[2];
}
bool MarginAction_IsValid(int value) {
  switch (value) {
    case 0:
    case 10:
    case 20:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ArticleAction_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_messages_2eproto);
  return file_level_enum_descriptors_messages_2eproto[3];
}
bool ArticleAction_IsValid(int value) {
  switch (value) {
    case 0:
    case 10:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class Message::_Internal {
 public:
  static const ::np2ps::ArticleAll& article_all(const Message* msg);
  static const ::np2ps::ArticleHeader& article_header(const Message* msg);
  static const ::np2ps::ArticleSolicitation& article_sol(const Message* msg);
  static const ::np2ps::ArticleList& article_list(const Message* msg);
  static const ::np2ps::UserIsMember& user_is_member(const Message* msg);
  static const ::np2ps::ArticleDataUpdate& article_data_update(const Message* msg);
  static const ::np2ps::UpdateMargin& update_margin(const Message* msg);
  static const ::np2ps::UpdateArticle& update_article(const Message* msg);
  static const ::np2ps::Credentials& credentials(const Message* msg);
  static const ::np2ps::SymmetricKey& symmetric_key(const Message* msg);
  static const ::np2ps::PublicKey& public_key(const Message* msg);
};

const ::np2ps::ArticleAll&
Message::_Internal::article_all(const Message* msg) {
  return *msg->_impl_.message_oneof_.article_all_;
}
const ::np2ps::ArticleHeader&
Message::_Internal::article_header(const Message* msg) {
  return *msg->_impl_.message_oneof_.article_header_;
}
const ::np2ps::ArticleSolicitation&
Message::_Internal::article_sol(const Message* msg) {
  return *msg->_impl_.message_oneof_.article_sol_;
}
const ::np2ps::ArticleList&
Message::_Internal::article_list(const Message* msg) {
  return *msg->_impl_.message_oneof_.article_list_;
}
const ::np2ps::UserIsMember&
Message::_Internal::user_is_member(const Message* msg) {
  return *msg->_impl_.message_oneof_.user_is_member_;
}
const ::np2ps::ArticleDataUpdate&
Message::_Internal::article_data_update(const Message* msg) {
  return *msg->_impl_.message_oneof_.article_data_update_;
}
const ::np2ps::UpdateMargin&
Message::_Internal::update_margin(const Message* msg) {
  return *msg->_impl_.message_oneof_.update_margin_;
}
const ::np2ps::UpdateArticle&
Message::_Internal::update_article(const Message* msg) {
  return *msg->_impl_.message_oneof_.update_article_;
}
const ::np2ps::Credentials&
Message::_Internal::credentials(const Message* msg) {
  return *msg->_impl_.message_oneof_.credentials_;
}
const ::np2ps::SymmetricKey&
Message::_Internal::symmetric_key(const Message* msg) {
  return *msg->_impl_.message_oneof_.symmetric_key_;
}
const ::np2ps::PublicKey&
Message::_Internal::public_key(const Message* msg) {
  return *msg->_impl_.message_oneof_.public_key_;
}
void Message::set_allocated_article_all(::np2ps::ArticleAll* article_all) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message_oneof();
  if (article_all) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(article_all);
    if (message_arena != submessage_arena) {
      article_all = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, article_all, submessage_arena);
    }
    set_has_article_all();
    _impl_.message_oneof_.article_all_ = article_all;
  }
  // @@protoc_insertion_point(field_set_allocated:np2ps.Message.article_all)
}
void Message::set_allocated_article_header(::np2ps::ArticleHeader* article_header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message_oneof();
  if (article_header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(article_header);
    if (message_arena != submessage_arena) {
      article_header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, article_header, submessage_arena);
    }
    set_has_article_header();
    _impl_.message_oneof_.article_header_ = article_header;
  }
  // @@protoc_insertion_point(field_set_allocated:np2ps.Message.article_header)
}
void Message::set_allocated_article_sol(::np2ps::ArticleSolicitation* article_sol) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message_oneof();
  if (article_sol) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(article_sol);
    if (message_arena != submessage_arena) {
      article_sol = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, article_sol, submessage_arena);
    }
    set_has_article_sol();
    _impl_.message_oneof_.article_sol_ = article_sol;
  }
  // @@protoc_insertion_point(field_set_allocated:np2ps.Message.article_sol)
}
void Message::set_allocated_article_list(::np2ps::ArticleList* article_list) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message_oneof();
  if (article_list) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(article_list);
    if (message_arena != submessage_arena) {
      article_list = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, article_list, submessage_arena);
    }
    set_has_article_list();
    _impl_.message_oneof_.article_list_ = article_list;
  }
  // @@protoc_insertion_point(field_set_allocated:np2ps.Message.article_list)
}
void Message::set_allocated_user_is_member(::np2ps::UserIsMember* user_is_member) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message_oneof();
  if (user_is_member) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(user_is_member);
    if (message_arena != submessage_arena) {
      user_is_member = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user_is_member, submessage_arena);
    }
    set_has_user_is_member();
    _impl_.message_oneof_.user_is_member_ = user_is_member;
  }
  // @@protoc_insertion_point(field_set_allocated:np2ps.Message.user_is_member)
}
void Message::set_allocated_article_data_update(::np2ps::ArticleDataUpdate* article_data_update) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message_oneof();
  if (article_data_update) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(article_data_update);
    if (message_arena != submessage_arena) {
      article_data_update = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, article_data_update, submessage_arena);
    }
    set_has_article_data_update();
    _impl_.message_oneof_.article_data_update_ = article_data_update;
  }
  // @@protoc_insertion_point(field_set_allocated:np2ps.Message.article_data_update)
}
void Message::set_allocated_update_margin(::np2ps::UpdateMargin* update_margin) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message_oneof();
  if (update_margin) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(update_margin);
    if (message_arena != submessage_arena) {
      update_margin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, update_margin, submessage_arena);
    }
    set_has_update_margin();
    _impl_.message_oneof_.update_margin_ = update_margin;
  }
  // @@protoc_insertion_point(field_set_allocated:np2ps.Message.update_margin)
}
void Message::set_allocated_update_article(::np2ps::UpdateArticle* update_article) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message_oneof();
  if (update_article) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(update_article);
    if (message_arena != submessage_arena) {
      update_article = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, update_article, submessage_arena);
    }
    set_has_update_article();
    _impl_.message_oneof_.update_article_ = update_article;
  }
  // @@protoc_insertion_point(field_set_allocated:np2ps.Message.update_article)
}
void Message::set_allocated_credentials(::np2ps::Credentials* credentials) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message_oneof();
  if (credentials) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(credentials);
    if (message_arena != submessage_arena) {
      credentials = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, credentials, submessage_arena);
    }
    set_has_credentials();
    _impl_.message_oneof_.credentials_ = credentials;
  }
  // @@protoc_insertion_point(field_set_allocated:np2ps.Message.credentials)
}
void Message::set_allocated_symmetric_key(::np2ps::SymmetricKey* symmetric_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message_oneof();
  if (symmetric_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(symmetric_key);
    if (message_arena != submessage_arena) {
      symmetric_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, symmetric_key, submessage_arena);
    }
    set_has_symmetric_key();
    _impl_.message_oneof_.symmetric_key_ = symmetric_key;
  }
  // @@protoc_insertion_point(field_set_allocated:np2ps.Message.symmetric_key)
}
void Message::set_allocated_public_key(::np2ps::PublicKey* public_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message_oneof();
  if (public_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(public_key);
    if (message_arena != submessage_arena) {
      public_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, public_key, submessage_arena);
    }
    set_has_public_key();
    _impl_.message_oneof_.public_key_ = public_key;
  }
  // @@protoc_insertion_point(field_set_allocated:np2ps.Message.public_key)
}
Message::Message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:np2ps.Message)
}
Message::Message(const Message& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Message* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.from_){}
    , decltype(_impl_.to_){}
    , decltype(_impl_.msg_type_){}
    , decltype(_impl_.msg_ctx_){}
    , decltype(_impl_.seq_){}
    , decltype(_impl_.message_oneof_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.from_, &from._impl_.from_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.seq_) -
    reinterpret_cast<char*>(&_impl_.from_)) + sizeof(_impl_.seq_));
  clear_has_message_oneof();
  switch (from.message_oneof_case()) {
    case kArticleAll: {
      _this->_internal_mutable_article_all()->::np2ps::ArticleAll::MergeFrom(
          from._internal_article_all());
      break;
    }
    case kArticleHeader: {
      _this->_internal_mutable_article_header()->::np2ps::ArticleHeader::MergeFrom(
          from._internal_article_header());
      break;
    }
    case kArticleSol: {
      _this->_internal_mutable_article_sol()->::np2ps::ArticleSolicitation::MergeFrom(
          from._internal_article_sol());
      break;
    }
    case kArticleList: {
      _this->_internal_mutable_article_list()->::np2ps::ArticleList::MergeFrom(
          from._internal_article_list());
      break;
    }
    case kUserIsMember: {
      _this->_internal_mutable_user_is_member()->::np2ps::UserIsMember::MergeFrom(
          from._internal_user_is_member());
      break;
    }
    case kArticleDataUpdate: {
      _this->_internal_mutable_article_data_update()->::np2ps::ArticleDataUpdate::MergeFrom(
          from._internal_article_data_update());
      break;
    }
    case kUpdateMargin: {
      _this->_internal_mutable_update_margin()->::np2ps::UpdateMargin::MergeFrom(
          from._internal_update_margin());
      break;
    }
    case kUpdateArticle: {
      _this->_internal_mutable_update_article()->::np2ps::UpdateArticle::MergeFrom(
          from._internal_update_article());
      break;
    }
    case kCredentials: {
      _this->_internal_mutable_credentials()->::np2ps::Credentials::MergeFrom(
          from._internal_credentials());
      break;
    }
    case kSymmetricKey: {
      _this->_internal_mutable_symmetric_key()->::np2ps::SymmetricKey::MergeFrom(
          from._internal_symmetric_key());
      break;
    }
    case kPublicKey: {
      _this->_internal_mutable_public_key()->::np2ps::PublicKey::MergeFrom(
          from._internal_public_key());
      break;
    }
    case MESSAGE_ONEOF_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:np2ps.Message)
}

inline void Message::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.from_){uint64_t{0u}}
    , decltype(_impl_.to_){uint64_t{0u}}
    , decltype(_impl_.msg_type_){0}
    , decltype(_impl_.msg_ctx_){0}
    , decltype(_impl_.seq_){uint64_t{0u}}
    , decltype(_impl_.message_oneof_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_message_oneof();
}

Message::~Message() {
  // @@protoc_insertion_point(destructor:np2ps.Message)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Message::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_message_oneof()) {
    clear_message_oneof();
  }
}

void Message::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Message::clear_message_oneof() {
// @@protoc_insertion_point(one_of_clear_start:np2ps.Message)
  switch (message_oneof_case()) {
    case kArticleAll: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_oneof_.article_all_;
      }
      break;
    }
    case kArticleHeader: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_oneof_.article_header_;
      }
      break;
    }
    case kArticleSol: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_oneof_.article_sol_;
      }
      break;
    }
    case kArticleList: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_oneof_.article_list_;
      }
      break;
    }
    case kUserIsMember: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_oneof_.user_is_member_;
      }
      break;
    }
    case kArticleDataUpdate: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_oneof_.article_data_update_;
      }
      break;
    }
    case kUpdateMargin: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_oneof_.update_margin_;
      }
      break;
    }
    case kUpdateArticle: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_oneof_.update_article_;
      }
      break;
    }
    case kCredentials: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_oneof_.credentials_;
      }
      break;
    }
    case kSymmetricKey: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_oneof_.symmetric_key_;
      }
      break;
    }
    case kPublicKey: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_oneof_.public_key_;
      }
      break;
    }
    case MESSAGE_ONEOF_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = MESSAGE_ONEOF_NOT_SET;
}


void Message::Clear() {
// @@protoc_insertion_point(message_clear_start:np2ps.Message)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.from_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.seq_) -
      reinterpret_cast<char*>(&_impl_.from_)) + sizeof(_impl_.seq_));
  clear_message_oneof();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Message::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 from = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.from_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 to = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.to_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .np2ps.MessageType msg_type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_msg_type(static_cast<::np2ps::MessageType>(val));
        } else
          goto handle_unusual;
        continue;
      // .np2ps.MessageContext msg_ctx = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_msg_ctx(static_cast<::np2ps::MessageContext>(val));
        } else
          goto handle_unusual;
        continue;
      // uint64 seq = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.seq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .np2ps.ArticleAll article_all = 110;
      case 110:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_article_all(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .np2ps.ArticleHeader article_header = 120;
      case 120:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 194)) {
          ptr = ctx->ParseMessage(_internal_mutable_article_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .np2ps.ArticleSolicitation article_sol = 121;
      case 121:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 202)) {
          ptr = ctx->ParseMessage(_internal_mutable_article_sol(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .np2ps.ArticleList article_list = 125;
      case 125:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 234)) {
          ptr = ctx->ParseMessage(_internal_mutable_article_list(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .np2ps.UserIsMember user_is_member = 130;
      case 130:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_user_is_member(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .np2ps.ArticleDataUpdate article_data_update = 140;
      case 140:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_article_data_update(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .np2ps.UpdateMargin update_margin = 170;
      case 170:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_update_margin(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .np2ps.UpdateArticle update_article = 180;
      case 180:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_update_article(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .np2ps.Credentials credentials = 200;
      case 200:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_credentials(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .np2ps.SymmetricKey symmetric_key = 210;
      case 210:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_symmetric_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .np2ps.PublicKey public_key = 220;
      case 220:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 226)) {
          ptr = ctx->ParseMessage(_internal_mutable_public_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Message::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:np2ps.Message)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 from = 1;
  if (this->_internal_from() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_from(), target);
  }

  // uint64 to = 2;
  if (this->_internal_to() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_to(), target);
  }

  // .np2ps.MessageType msg_type = 3;
  if (this->_internal_msg_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_msg_type(), target);
  }

  // .np2ps.MessageContext msg_ctx = 4;
  if (this->_internal_msg_ctx() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_msg_ctx(), target);
  }

  // uint64 seq = 5;
  if (this->_internal_seq() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_seq(), target);
  }

  // .np2ps.ArticleAll article_all = 110;
  if (_internal_has_article_all()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(110, _Internal::article_all(this),
        _Internal::article_all(this).GetCachedSize(), target, stream);
  }

  // .np2ps.ArticleHeader article_header = 120;
  if (_internal_has_article_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(120, _Internal::article_header(this),
        _Internal::article_header(this).GetCachedSize(), target, stream);
  }

  // .np2ps.ArticleSolicitation article_sol = 121;
  if (_internal_has_article_sol()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(121, _Internal::article_sol(this),
        _Internal::article_sol(this).GetCachedSize(), target, stream);
  }

  // .np2ps.ArticleList article_list = 125;
  if (_internal_has_article_list()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(125, _Internal::article_list(this),
        _Internal::article_list(this).GetCachedSize(), target, stream);
  }

  // .np2ps.UserIsMember user_is_member = 130;
  if (_internal_has_user_is_member()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(130, _Internal::user_is_member(this),
        _Internal::user_is_member(this).GetCachedSize(), target, stream);
  }

  // .np2ps.ArticleDataUpdate article_data_update = 140;
  if (_internal_has_article_data_update()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(140, _Internal::article_data_update(this),
        _Internal::article_data_update(this).GetCachedSize(), target, stream);
  }

  // .np2ps.UpdateMargin update_margin = 170;
  if (_internal_has_update_margin()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(170, _Internal::update_margin(this),
        _Internal::update_margin(this).GetCachedSize(), target, stream);
  }

  // .np2ps.UpdateArticle update_article = 180;
  if (_internal_has_update_article()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(180, _Internal::update_article(this),
        _Internal::update_article(this).GetCachedSize(), target, stream);
  }

  // .np2ps.Credentials credentials = 200;
  if (_internal_has_credentials()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(200, _Internal::credentials(this),
        _Internal::credentials(this).GetCachedSize(), target, stream);
  }

  // .np2ps.SymmetricKey symmetric_key = 210;
  if (_internal_has_symmetric_key()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(210, _Internal::symmetric_key(this),
        _Internal::symmetric_key(this).GetCachedSize(), target, stream);
  }

  // .np2ps.PublicKey public_key = 220;
  if (_internal_has_public_key()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(220, _Internal::public_key(this),
        _Internal::public_key(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:np2ps.Message)
  return target;
}

size_t Message::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:np2ps.Message)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 from = 1;
  if (this->_internal_from() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_from());
  }

  // uint64 to = 2;
  if (this->_internal_to() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_to());
  }

  // .np2ps.MessageType msg_type = 3;
  if (this->_internal_msg_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_msg_type());
  }

  // .np2ps.MessageContext msg_ctx = 4;
  if (this->_internal_msg_ctx() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_msg_ctx());
  }

  // uint64 seq = 5;
  if (this->_internal_seq() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_seq());
  }

  switch (message_oneof_case()) {
    // .np2ps.ArticleAll article_all = 110;
    case kArticleAll: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_oneof_.article_all_);
      break;
    }
    // .np2ps.ArticleHeader article_header = 120;
    case kArticleHeader: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_oneof_.article_header_);
      break;
    }
    // .np2ps.ArticleSolicitation article_sol = 121;
    case kArticleSol: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_oneof_.article_sol_);
      break;
    }
    // .np2ps.ArticleList article_list = 125;
    case kArticleList: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_oneof_.article_list_);
      break;
    }
    // .np2ps.UserIsMember user_is_member = 130;
    case kUserIsMember: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_oneof_.user_is_member_);
      break;
    }
    // .np2ps.ArticleDataUpdate article_data_update = 140;
    case kArticleDataUpdate: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_oneof_.article_data_update_);
      break;
    }
    // .np2ps.UpdateMargin update_margin = 170;
    case kUpdateMargin: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_oneof_.update_margin_);
      break;
    }
    // .np2ps.UpdateArticle update_article = 180;
    case kUpdateArticle: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_oneof_.update_article_);
      break;
    }
    // .np2ps.Credentials credentials = 200;
    case kCredentials: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_oneof_.credentials_);
      break;
    }
    // .np2ps.SymmetricKey symmetric_key = 210;
    case kSymmetricKey: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_oneof_.symmetric_key_);
      break;
    }
    // .np2ps.PublicKey public_key = 220;
    case kPublicKey: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_oneof_.public_key_);
      break;
    }
    case MESSAGE_ONEOF_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Message::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Message::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Message::GetClassData() const { return &_class_data_; }


void Message::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Message*>(&to_msg);
  auto& from = static_cast<const Message&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:np2ps.Message)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_from() != 0) {
    _this->_internal_set_from(from._internal_from());
  }
  if (from._internal_to() != 0) {
    _this->_internal_set_to(from._internal_to());
  }
  if (from._internal_msg_type() != 0) {
    _this->_internal_set_msg_type(from._internal_msg_type());
  }
  if (from._internal_msg_ctx() != 0) {
    _this->_internal_set_msg_ctx(from._internal_msg_ctx());
  }
  if (from._internal_seq() != 0) {
    _this->_internal_set_seq(from._internal_seq());
  }
  switch (from.message_oneof_case()) {
    case kArticleAll: {
      _this->_internal_mutable_article_all()->::np2ps::ArticleAll::MergeFrom(
          from._internal_article_all());
      break;
    }
    case kArticleHeader: {
      _this->_internal_mutable_article_header()->::np2ps::ArticleHeader::MergeFrom(
          from._internal_article_header());
      break;
    }
    case kArticleSol: {
      _this->_internal_mutable_article_sol()->::np2ps::ArticleSolicitation::MergeFrom(
          from._internal_article_sol());
      break;
    }
    case kArticleList: {
      _this->_internal_mutable_article_list()->::np2ps::ArticleList::MergeFrom(
          from._internal_article_list());
      break;
    }
    case kUserIsMember: {
      _this->_internal_mutable_user_is_member()->::np2ps::UserIsMember::MergeFrom(
          from._internal_user_is_member());
      break;
    }
    case kArticleDataUpdate: {
      _this->_internal_mutable_article_data_update()->::np2ps::ArticleDataUpdate::MergeFrom(
          from._internal_article_data_update());
      break;
    }
    case kUpdateMargin: {
      _this->_internal_mutable_update_margin()->::np2ps::UpdateMargin::MergeFrom(
          from._internal_update_margin());
      break;
    }
    case kUpdateArticle: {
      _this->_internal_mutable_update_article()->::np2ps::UpdateArticle::MergeFrom(
          from._internal_update_article());
      break;
    }
    case kCredentials: {
      _this->_internal_mutable_credentials()->::np2ps::Credentials::MergeFrom(
          from._internal_credentials());
      break;
    }
    case kSymmetricKey: {
      _this->_internal_mutable_symmetric_key()->::np2ps::SymmetricKey::MergeFrom(
          from._internal_symmetric_key());
      break;
    }
    case kPublicKey: {
      _this->_internal_mutable_public_key()->::np2ps::PublicKey::MergeFrom(
          from._internal_public_key());
      break;
    }
    case MESSAGE_ONEOF_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Message::CopyFrom(const Message& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:np2ps.Message)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Message::IsInitialized() const {
  return true;
}

void Message::InternalSwap(Message* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Message, _impl_.seq_)
      + sizeof(Message::_impl_.seq_)
      - PROTOBUF_FIELD_OFFSET(Message, _impl_.from_)>(
          reinterpret_cast<char*>(&_impl_.from_),
          reinterpret_cast<char*>(&other->_impl_.from_));
  swap(_impl_.message_oneof_, other->_impl_.message_oneof_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Message::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2eproto_getter, &descriptor_table_messages_2eproto_once,
      file_level_metadata_messages_2eproto[0]);
}

// ===================================================================

class ArticleAll::_Internal {
 public:
  using HasBits = decltype(std::declval<ArticleAll>()._impl_._has_bits_);
  static const ::np2ps::Article& header(const ArticleAll* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_article_actual(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::np2ps::Article&
ArticleAll::_Internal::header(const ArticleAll* msg) {
  return *msg->_impl_.header_;
}
void ArticleAll::clear_header() {
  if (_impl_.header_ != nullptr) _impl_.header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
ArticleAll::ArticleAll(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:np2ps.ArticleAll)
}
ArticleAll::ArticleAll(const ArticleAll& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ArticleAll* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.article_actual_){}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.article_hash_){}
    , decltype(_impl_.level_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.article_actual_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.article_actual_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_article_actual()) {
    _this->_impl_.article_actual_.Set(from._internal_article_actual(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_header()) {
    _this->_impl_.header_ = new ::np2ps::Article(*from._impl_.header_);
  }
  ::memcpy(&_impl_.article_hash_, &from._impl_.article_hash_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.level_) -
    reinterpret_cast<char*>(&_impl_.article_hash_)) + sizeof(_impl_.level_));
  // @@protoc_insertion_point(copy_constructor:np2ps.ArticleAll)
}

inline void ArticleAll::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.article_actual_){}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.article_hash_){uint64_t{0u}}
    , decltype(_impl_.level_){0u}
  };
  _impl_.article_actual_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.article_actual_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ArticleAll::~ArticleAll() {
  // @@protoc_insertion_point(destructor:np2ps.ArticleAll)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ArticleAll::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.article_actual_.Destroy();
  if (this != internal_default_instance()) delete _impl_.header_;
}

void ArticleAll::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ArticleAll::Clear() {
// @@protoc_insertion_point(message_clear_start:np2ps.ArticleAll)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.article_actual_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.header_ != nullptr);
      _impl_.header_->Clear();
    }
  }
  ::memset(&_impl_.article_hash_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.level_) -
      reinterpret_cast<char*>(&_impl_.article_hash_)) + sizeof(_impl_.level_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ArticleAll::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 article_hash = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.article_hash_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 level = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .np2ps.Article header = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string article_actual = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_article_actual();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "np2ps.ArticleAll.article_actual"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ArticleAll::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:np2ps.ArticleAll)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 article_hash = 1;
  if (this->_internal_article_hash() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_article_hash(), target);
  }

  // uint32 level = 2;
  if (this->_internal_level() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_level(), target);
  }

  // optional .np2ps.Article header = 3;
  if (_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // optional string article_actual = 4;
  if (_internal_has_article_actual()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_article_actual().data(), static_cast<int>(this->_internal_article_actual().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "np2ps.ArticleAll.article_actual");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_article_actual(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:np2ps.ArticleAll)
  return target;
}

size_t ArticleAll::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:np2ps.ArticleAll)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string article_actual = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_article_actual());
    }

    // optional .np2ps.Article header = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.header_);
    }

  }
  // uint64 article_hash = 1;
  if (this->_internal_article_hash() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_article_hash());
  }

  // uint32 level = 2;
  if (this->_internal_level() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_level());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ArticleAll::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ArticleAll::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ArticleAll::GetClassData() const { return &_class_data_; }


void ArticleAll::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ArticleAll*>(&to_msg);
  auto& from = static_cast<const ArticleAll&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:np2ps.ArticleAll)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_article_actual(from._internal_article_actual());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_header()->::np2ps::Article::MergeFrom(
          from._internal_header());
    }
  }
  if (from._internal_article_hash() != 0) {
    _this->_internal_set_article_hash(from._internal_article_hash());
  }
  if (from._internal_level() != 0) {
    _this->_internal_set_level(from._internal_level());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ArticleAll::CopyFrom(const ArticleAll& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:np2ps.ArticleAll)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ArticleAll::IsInitialized() const {
  return true;
}

void ArticleAll::InternalSwap(ArticleAll* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.article_actual_, lhs_arena,
      &other->_impl_.article_actual_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ArticleAll, _impl_.level_)
      + sizeof(ArticleAll::_impl_.level_)
      - PROTOBUF_FIELD_OFFSET(ArticleAll, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ArticleAll::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2eproto_getter, &descriptor_table_messages_2eproto_once,
      file_level_metadata_messages_2eproto[1]);
}

// ===================================================================

class ArticleHeader::_Internal {
 public:
  using HasBits = decltype(std::declval<ArticleHeader>()._impl_._has_bits_);
  static const ::np2ps::Article& article(const ArticleHeader* msg);
  static void set_has_article(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::np2ps::Article&
ArticleHeader::_Internal::article(const ArticleHeader* msg) {
  return *msg->_impl_.article_;
}
void ArticleHeader::clear_article() {
  if (_impl_.article_ != nullptr) _impl_.article_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
ArticleHeader::ArticleHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:np2ps.ArticleHeader)
}
ArticleHeader::ArticleHeader(const ArticleHeader& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ArticleHeader* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.article_){nullptr}
    , decltype(_impl_.article_hash_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_article()) {
    _this->_impl_.article_ = new ::np2ps::Article(*from._impl_.article_);
  }
  _this->_impl_.article_hash_ = from._impl_.article_hash_;
  // @@protoc_insertion_point(copy_constructor:np2ps.ArticleHeader)
}

inline void ArticleHeader::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.article_){nullptr}
    , decltype(_impl_.article_hash_){uint64_t{0u}}
  };
}

ArticleHeader::~ArticleHeader() {
  // @@protoc_insertion_point(destructor:np2ps.ArticleHeader)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ArticleHeader::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.article_;
}

void ArticleHeader::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ArticleHeader::Clear() {
// @@protoc_insertion_point(message_clear_start:np2ps.ArticleHeader)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.article_ != nullptr);
    _impl_.article_->Clear();
  }
  _impl_.article_hash_ = uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ArticleHeader::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 article_hash = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.article_hash_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .np2ps.Article article = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_article(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ArticleHeader::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:np2ps.ArticleHeader)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 article_hash = 2;
  if (this->_internal_article_hash() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_article_hash(), target);
  }

  // optional .np2ps.Article article = 4;
  if (_internal_has_article()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::article(this),
        _Internal::article(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:np2ps.ArticleHeader)
  return target;
}

size_t ArticleHeader::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:np2ps.ArticleHeader)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .np2ps.Article article = 4;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.article_);
  }

  // uint64 article_hash = 2;
  if (this->_internal_article_hash() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_article_hash());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ArticleHeader::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ArticleHeader::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ArticleHeader::GetClassData() const { return &_class_data_; }


void ArticleHeader::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ArticleHeader*>(&to_msg);
  auto& from = static_cast<const ArticleHeader&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:np2ps.ArticleHeader)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_article()) {
    _this->_internal_mutable_article()->::np2ps::Article::MergeFrom(
        from._internal_article());
  }
  if (from._internal_article_hash() != 0) {
    _this->_internal_set_article_hash(from._internal_article_hash());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ArticleHeader::CopyFrom(const ArticleHeader& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:np2ps.ArticleHeader)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ArticleHeader::IsInitialized() const {
  return true;
}

void ArticleHeader::InternalSwap(ArticleHeader* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ArticleHeader, _impl_.article_hash_)
      + sizeof(ArticleHeader::_impl_.article_hash_)
      - PROTOBUF_FIELD_OFFSET(ArticleHeader, _impl_.article_)>(
          reinterpret_cast<char*>(&_impl_.article_),
          reinterpret_cast<char*>(&other->_impl_.article_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ArticleHeader::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2eproto_getter, &descriptor_table_messages_2eproto_once,
      file_level_metadata_messages_2eproto[2]);
}

// ===================================================================

class ArticleList::_Internal {
 public:
};

void ArticleList::clear_response() {
  _impl_.response_.Clear();
}
ArticleList::ArticleList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:np2ps.ArticleList)
}
ArticleList::ArticleList(const ArticleList& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ArticleList* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.categories_){from._impl_.categories_}
    , decltype(_impl_.response_){from._impl_.response_}
    , decltype(_impl_.all_articles_){}
    , decltype(_impl_.count_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.all_articles_, &from._impl_.all_articles_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.count_) -
    reinterpret_cast<char*>(&_impl_.all_articles_)) + sizeof(_impl_.count_));
  // @@protoc_insertion_point(copy_constructor:np2ps.ArticleList)
}

inline void ArticleList::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.categories_){arena}
    , decltype(_impl_.response_){arena}
    , decltype(_impl_.all_articles_){false}
    , decltype(_impl_.count_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ArticleList::~ArticleList() {
  // @@protoc_insertion_point(destructor:np2ps.ArticleList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ArticleList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.categories_.~RepeatedPtrField();
  _impl_.response_.~RepeatedPtrField();
}

void ArticleList::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ArticleList::Clear() {
// @@protoc_insertion_point(message_clear_start:np2ps.ArticleList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.categories_.Clear();
  _impl_.response_.Clear();
  ::memset(&_impl_.all_articles_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.count_) -
      reinterpret_cast<char*>(&_impl_.all_articles_)) + sizeof(_impl_.count_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ArticleList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool all_articles = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.all_articles_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string categories = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_categories();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "np2ps.ArticleList.categories"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .np2ps.Article response = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_response(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // int32 count = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ArticleList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:np2ps.ArticleList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool all_articles = 1;
  if (this->_internal_all_articles() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_all_articles(), target);
  }

  // repeated string categories = 2;
  for (int i = 0, n = this->_internal_categories_size(); i < n; i++) {
    const auto& s = this->_internal_categories(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "np2ps.ArticleList.categories");
    target = stream->WriteString(2, s, target);
  }

  // repeated .np2ps.Article response = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_response_size()); i < n; i++) {
    const auto& repfield = this->_internal_response(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // int32 count = 4;
  if (this->_internal_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_count(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:np2ps.ArticleList)
  return target;
}

size_t ArticleList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:np2ps.ArticleList)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string categories = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.categories_.size());
  for (int i = 0, n = _impl_.categories_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.categories_.Get(i));
  }

  // repeated .np2ps.Article response = 3;
  total_size += 1UL * this->_internal_response_size();
  for (const auto& msg : this->_impl_.response_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // bool all_articles = 1;
  if (this->_internal_all_articles() != 0) {
    total_size += 1 + 1;
  }

  // int32 count = 4;
  if (this->_internal_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_count());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ArticleList::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ArticleList::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ArticleList::GetClassData() const { return &_class_data_; }


void ArticleList::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ArticleList*>(&to_msg);
  auto& from = static_cast<const ArticleList&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:np2ps.ArticleList)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.categories_.MergeFrom(from._impl_.categories_);
  _this->_impl_.response_.MergeFrom(from._impl_.response_);
  if (from._internal_all_articles() != 0) {
    _this->_internal_set_all_articles(from._internal_all_articles());
  }
  if (from._internal_count() != 0) {
    _this->_internal_set_count(from._internal_count());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ArticleList::CopyFrom(const ArticleList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:np2ps.ArticleList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ArticleList::IsInitialized() const {
  return true;
}

void ArticleList::InternalSwap(ArticleList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.categories_.InternalSwap(&other->_impl_.categories_);
  _impl_.response_.InternalSwap(&other->_impl_.response_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ArticleList, _impl_.count_)
      + sizeof(ArticleList::_impl_.count_)
      - PROTOBUF_FIELD_OFFSET(ArticleList, _impl_.all_articles_)>(
          reinterpret_cast<char*>(&_impl_.all_articles_),
          reinterpret_cast<char*>(&other->_impl_.all_articles_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ArticleList::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2eproto_getter, &descriptor_table_messages_2eproto_once,
      file_level_metadata_messages_2eproto[3]);
}

// ===================================================================

class ArticleSolicitation::_Internal {
 public:
  using HasBits = decltype(std::declval<ArticleSolicitation>()._impl_._has_bits_);
  static void set_has_level(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ArticleSolicitation::ArticleSolicitation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:np2ps.ArticleSolicitation)
}
ArticleSolicitation::ArticleSolicitation(const ArticleSolicitation& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ArticleSolicitation* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.possible_owners_){from._impl_.possible_owners_}
    , /*decltype(_impl_._possible_owners_cached_byte_size_)*/{0}
    , decltype(_impl_.article_hash_){}
    , decltype(_impl_.level_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.article_hash_, &from._impl_.article_hash_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.level_) -
    reinterpret_cast<char*>(&_impl_.article_hash_)) + sizeof(_impl_.level_));
  // @@protoc_insertion_point(copy_constructor:np2ps.ArticleSolicitation)
}

inline void ArticleSolicitation::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.possible_owners_){arena}
    , /*decltype(_impl_._possible_owners_cached_byte_size_)*/{0}
    , decltype(_impl_.article_hash_){uint64_t{0u}}
    , decltype(_impl_.level_){0u}
  };
}

ArticleSolicitation::~ArticleSolicitation() {
  // @@protoc_insertion_point(destructor:np2ps.ArticleSolicitation)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ArticleSolicitation::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.possible_owners_.~RepeatedField();
}

void ArticleSolicitation::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ArticleSolicitation::Clear() {
// @@protoc_insertion_point(message_clear_start:np2ps.ArticleSolicitation)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.possible_owners_.Clear();
  _impl_.article_hash_ = uint64_t{0u};
  _impl_.level_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ArticleSolicitation::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 article_hash = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.article_hash_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 possible_owners = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_possible_owners(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 16) {
          _internal_add_possible_owners(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 level = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_level(&has_bits);
          _impl_.level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ArticleSolicitation::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:np2ps.ArticleSolicitation)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 article_hash = 1;
  if (this->_internal_article_hash() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_article_hash(), target);
  }

  // repeated uint64 possible_owners = 2;
  {
    int byte_size = _impl_._possible_owners_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt64Packed(
          2, _internal_possible_owners(), byte_size, target);
    }
  }

  // optional uint32 level = 3;
  if (_internal_has_level()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_level(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:np2ps.ArticleSolicitation)
  return target;
}

size_t ArticleSolicitation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:np2ps.ArticleSolicitation)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 possible_owners = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_.possible_owners_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._possible_owners_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // uint64 article_hash = 1;
  if (this->_internal_article_hash() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_article_hash());
  }

  // optional uint32 level = 3;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_level());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ArticleSolicitation::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ArticleSolicitation::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ArticleSolicitation::GetClassData() const { return &_class_data_; }


void ArticleSolicitation::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ArticleSolicitation*>(&to_msg);
  auto& from = static_cast<const ArticleSolicitation&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:np2ps.ArticleSolicitation)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.possible_owners_.MergeFrom(from._impl_.possible_owners_);
  if (from._internal_article_hash() != 0) {
    _this->_internal_set_article_hash(from._internal_article_hash());
  }
  if (from._internal_has_level()) {
    _this->_internal_set_level(from._internal_level());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ArticleSolicitation::CopyFrom(const ArticleSolicitation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:np2ps.ArticleSolicitation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ArticleSolicitation::IsInitialized() const {
  return true;
}

void ArticleSolicitation::InternalSwap(ArticleSolicitation* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.possible_owners_.InternalSwap(&other->_impl_.possible_owners_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ArticleSolicitation, _impl_.level_)
      + sizeof(ArticleSolicitation::_impl_.level_)
      - PROTOBUF_FIELD_OFFSET(ArticleSolicitation, _impl_.article_hash_)>(
          reinterpret_cast<char*>(&_impl_.article_hash_),
          reinterpret_cast<char*>(&other->_impl_.article_hash_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ArticleSolicitation::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2eproto_getter, &descriptor_table_messages_2eproto_once,
      file_level_metadata_messages_2eproto[4]);
}

// ===================================================================

class UserIsMember::_Internal {
 public:
};

UserIsMember::UserIsMember(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:np2ps.UserIsMember)
}
UserIsMember::UserIsMember(const UserIsMember& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UserIsMember* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.user_pk_){}
    , decltype(_impl_.level_){}
    , decltype(_impl_.is_member_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.user_pk_, &from._impl_.user_pk_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_member_) -
    reinterpret_cast<char*>(&_impl_.user_pk_)) + sizeof(_impl_.is_member_));
  // @@protoc_insertion_point(copy_constructor:np2ps.UserIsMember)
}

inline void UserIsMember::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.user_pk_){uint64_t{0u}}
    , decltype(_impl_.level_){0u}
    , decltype(_impl_.is_member_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

UserIsMember::~UserIsMember() {
  // @@protoc_insertion_point(destructor:np2ps.UserIsMember)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UserIsMember::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void UserIsMember::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UserIsMember::Clear() {
// @@protoc_insertion_point(message_clear_start:np2ps.UserIsMember)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.user_pk_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.is_member_) -
      reinterpret_cast<char*>(&_impl_.user_pk_)) + sizeof(_impl_.is_member_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UserIsMember::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 user_pk = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.user_pk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 level = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool is_member = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.is_member_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UserIsMember::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:np2ps.UserIsMember)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 user_pk = 1;
  if (this->_internal_user_pk() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_user_pk(), target);
  }

  // uint32 level = 2;
  if (this->_internal_level() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_level(), target);
  }

  // bool is_member = 3;
  if (this->_internal_is_member() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_is_member(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:np2ps.UserIsMember)
  return target;
}

size_t UserIsMember::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:np2ps.UserIsMember)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 user_pk = 1;
  if (this->_internal_user_pk() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_user_pk());
  }

  // uint32 level = 2;
  if (this->_internal_level() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_level());
  }

  // bool is_member = 3;
  if (this->_internal_is_member() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UserIsMember::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UserIsMember::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UserIsMember::GetClassData() const { return &_class_data_; }


void UserIsMember::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UserIsMember*>(&to_msg);
  auto& from = static_cast<const UserIsMember&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:np2ps.UserIsMember)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_user_pk() != 0) {
    _this->_internal_set_user_pk(from._internal_user_pk());
  }
  if (from._internal_level() != 0) {
    _this->_internal_set_level(from._internal_level());
  }
  if (from._internal_is_member() != 0) {
    _this->_internal_set_is_member(from._internal_is_member());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UserIsMember::CopyFrom(const UserIsMember& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:np2ps.UserIsMember)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserIsMember::IsInitialized() const {
  return true;
}

void UserIsMember::InternalSwap(UserIsMember* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UserIsMember, _impl_.is_member_)
      + sizeof(UserIsMember::_impl_.is_member_)
      - PROTOBUF_FIELD_OFFSET(UserIsMember, _impl_.user_pk_)>(
          reinterpret_cast<char*>(&_impl_.user_pk_),
          reinterpret_cast<char*>(&other->_impl_.user_pk_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UserIsMember::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2eproto_getter, &descriptor_table_messages_2eproto_once,
      file_level_metadata_messages_2eproto[5]);
}

// ===================================================================

class ArticleDataUpdate::_Internal {
 public:
};

ArticleDataUpdate::ArticleDataUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:np2ps.ArticleDataUpdate)
}
ArticleDataUpdate::ArticleDataUpdate(const ArticleDataUpdate& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ArticleDataUpdate* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.article_pk_){}
    , decltype(_impl_.article_action_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.article_pk_, &from._impl_.article_pk_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.article_action_) -
    reinterpret_cast<char*>(&_impl_.article_pk_)) + sizeof(_impl_.article_action_));
  // @@protoc_insertion_point(copy_constructor:np2ps.ArticleDataUpdate)
}

inline void ArticleDataUpdate::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.article_pk_){uint64_t{0u}}
    , decltype(_impl_.article_action_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ArticleDataUpdate::~ArticleDataUpdate() {
  // @@protoc_insertion_point(destructor:np2ps.ArticleDataUpdate)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ArticleDataUpdate::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ArticleDataUpdate::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ArticleDataUpdate::Clear() {
// @@protoc_insertion_point(message_clear_start:np2ps.ArticleDataUpdate)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.article_pk_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.article_action_) -
      reinterpret_cast<char*>(&_impl_.article_pk_)) + sizeof(_impl_.article_action_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ArticleDataUpdate::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 article_pk = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.article_pk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .np2ps.ArticleAction article_action = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_article_action(static_cast<::np2ps::ArticleAction>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ArticleDataUpdate::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:np2ps.ArticleDataUpdate)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 article_pk = 1;
  if (this->_internal_article_pk() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_article_pk(), target);
  }

  // .np2ps.ArticleAction article_action = 3;
  if (this->_internal_article_action() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_article_action(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:np2ps.ArticleDataUpdate)
  return target;
}

size_t ArticleDataUpdate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:np2ps.ArticleDataUpdate)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 article_pk = 1;
  if (this->_internal_article_pk() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_article_pk());
  }

  // .np2ps.ArticleAction article_action = 3;
  if (this->_internal_article_action() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_article_action());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ArticleDataUpdate::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ArticleDataUpdate::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ArticleDataUpdate::GetClassData() const { return &_class_data_; }


void ArticleDataUpdate::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ArticleDataUpdate*>(&to_msg);
  auto& from = static_cast<const ArticleDataUpdate&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:np2ps.ArticleDataUpdate)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_article_pk() != 0) {
    _this->_internal_set_article_pk(from._internal_article_pk());
  }
  if (from._internal_article_action() != 0) {
    _this->_internal_set_article_action(from._internal_article_action());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ArticleDataUpdate::CopyFrom(const ArticleDataUpdate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:np2ps.ArticleDataUpdate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ArticleDataUpdate::IsInitialized() const {
  return true;
}

void ArticleDataUpdate::InternalSwap(ArticleDataUpdate* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ArticleDataUpdate, _impl_.article_action_)
      + sizeof(ArticleDataUpdate::_impl_.article_action_)
      - PROTOBUF_FIELD_OFFSET(ArticleDataUpdate, _impl_.article_pk_)>(
          reinterpret_cast<char*>(&_impl_.article_pk_),
          reinterpret_cast<char*>(&other->_impl_.article_pk_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ArticleDataUpdate::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2eproto_getter, &descriptor_table_messages_2eproto_once,
      file_level_metadata_messages_2eproto[6]);
}

// ===================================================================

class UpdateMargin::_Internal {
 public:
  static const ::np2ps::Margins& margin(const UpdateMargin* msg);
};

const ::np2ps::Margins&
UpdateMargin::_Internal::margin(const UpdateMargin* msg) {
  return *msg->_impl_.margin_;
}
void UpdateMargin::clear_margin() {
  if (GetArenaForAllocation() == nullptr && _impl_.margin_ != nullptr) {
    delete _impl_.margin_;
  }
  _impl_.margin_ = nullptr;
}
UpdateMargin::UpdateMargin(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:np2ps.UpdateMargin)
}
UpdateMargin::UpdateMargin(const UpdateMargin& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UpdateMargin* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.margin_){nullptr}
    , decltype(_impl_.article_pk_){}
    , decltype(_impl_.m_action_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_margin()) {
    _this->_impl_.margin_ = new ::np2ps::Margins(*from._impl_.margin_);
  }
  ::memcpy(&_impl_.article_pk_, &from._impl_.article_pk_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.m_action_) -
    reinterpret_cast<char*>(&_impl_.article_pk_)) + sizeof(_impl_.m_action_));
  // @@protoc_insertion_point(copy_constructor:np2ps.UpdateMargin)
}

inline void UpdateMargin::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.margin_){nullptr}
    , decltype(_impl_.article_pk_){uint64_t{0u}}
    , decltype(_impl_.m_action_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

UpdateMargin::~UpdateMargin() {
  // @@protoc_insertion_point(destructor:np2ps.UpdateMargin)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UpdateMargin::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.margin_;
}

void UpdateMargin::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UpdateMargin::Clear() {
// @@protoc_insertion_point(message_clear_start:np2ps.UpdateMargin)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.margin_ != nullptr) {
    delete _impl_.margin_;
  }
  _impl_.margin_ = nullptr;
  ::memset(&_impl_.article_pk_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.m_action_) -
      reinterpret_cast<char*>(&_impl_.article_pk_)) + sizeof(_impl_.m_action_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UpdateMargin::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 article_pk = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.article_pk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .np2ps.MarginAction m_action = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_m_action(static_cast<::np2ps::MarginAction>(val));
        } else
          goto handle_unusual;
        continue;
      // .np2ps.Margins margin = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_margin(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UpdateMargin::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:np2ps.UpdateMargin)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 article_pk = 1;
  if (this->_internal_article_pk() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_article_pk(), target);
  }

  // .np2ps.MarginAction m_action = 2;
  if (this->_internal_m_action() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_m_action(), target);
  }

  // .np2ps.Margins margin = 3;
  if (this->_internal_has_margin()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::margin(this),
        _Internal::margin(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:np2ps.UpdateMargin)
  return target;
}

size_t UpdateMargin::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:np2ps.UpdateMargin)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .np2ps.Margins margin = 3;
  if (this->_internal_has_margin()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.margin_);
  }

  // uint64 article_pk = 1;
  if (this->_internal_article_pk() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_article_pk());
  }

  // .np2ps.MarginAction m_action = 2;
  if (this->_internal_m_action() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_m_action());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UpdateMargin::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UpdateMargin::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UpdateMargin::GetClassData() const { return &_class_data_; }


void UpdateMargin::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UpdateMargin*>(&to_msg);
  auto& from = static_cast<const UpdateMargin&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:np2ps.UpdateMargin)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_margin()) {
    _this->_internal_mutable_margin()->::np2ps::Margins::MergeFrom(
        from._internal_margin());
  }
  if (from._internal_article_pk() != 0) {
    _this->_internal_set_article_pk(from._internal_article_pk());
  }
  if (from._internal_m_action() != 0) {
    _this->_internal_set_m_action(from._internal_m_action());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UpdateMargin::CopyFrom(const UpdateMargin& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:np2ps.UpdateMargin)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateMargin::IsInitialized() const {
  return true;
}

void UpdateMargin::InternalSwap(UpdateMargin* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UpdateMargin, _impl_.m_action_)
      + sizeof(UpdateMargin::_impl_.m_action_)
      - PROTOBUF_FIELD_OFFSET(UpdateMargin, _impl_.margin_)>(
          reinterpret_cast<char*>(&_impl_.margin_),
          reinterpret_cast<char*>(&other->_impl_.margin_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UpdateMargin::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2eproto_getter, &descriptor_table_messages_2eproto_once,
      file_level_metadata_messages_2eproto[7]);
}

// ===================================================================

class UpdateArticle::_Internal {
 public:
};

UpdateArticle::UpdateArticle(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:np2ps.UpdateArticle)
}
UpdateArticle::UpdateArticle(const UpdateArticle& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UpdateArticle* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.article_pk_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.article_pk_ = from._impl_.article_pk_;
  // @@protoc_insertion_point(copy_constructor:np2ps.UpdateArticle)
}

inline void UpdateArticle::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.article_pk_){uint64_t{0u}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

UpdateArticle::~UpdateArticle() {
  // @@protoc_insertion_point(destructor:np2ps.UpdateArticle)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UpdateArticle::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void UpdateArticle::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UpdateArticle::Clear() {
// @@protoc_insertion_point(message_clear_start:np2ps.UpdateArticle)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.article_pk_ = uint64_t{0u};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UpdateArticle::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 article_pk = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.article_pk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UpdateArticle::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:np2ps.UpdateArticle)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 article_pk = 1;
  if (this->_internal_article_pk() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_article_pk(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:np2ps.UpdateArticle)
  return target;
}

size_t UpdateArticle::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:np2ps.UpdateArticle)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 article_pk = 1;
  if (this->_internal_article_pk() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_article_pk());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UpdateArticle::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UpdateArticle::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UpdateArticle::GetClassData() const { return &_class_data_; }


void UpdateArticle::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UpdateArticle*>(&to_msg);
  auto& from = static_cast<const UpdateArticle&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:np2ps.UpdateArticle)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_article_pk() != 0) {
    _this->_internal_set_article_pk(from._internal_article_pk());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UpdateArticle::CopyFrom(const UpdateArticle& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:np2ps.UpdateArticle)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateArticle::IsInitialized() const {
  return true;
}

void UpdateArticle::InternalSwap(UpdateArticle* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.article_pk_, other->_impl_.article_pk_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UpdateArticle::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2eproto_getter, &descriptor_table_messages_2eproto_once,
      file_level_metadata_messages_2eproto[8]);
}

// ===================================================================

class Credentials::_Internal {
 public:
  using HasBits = decltype(std::declval<Credentials>()._impl_._has_bits_);
  static void set_has_ipv4(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ipv6(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_rsa_public_key(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_eax_key(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

Credentials::Credentials(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:np2ps.Credentials)
}
Credentials::Credentials(const Credentials& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Credentials* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ipv4_){}
    , decltype(_impl_.ipv6_){}
    , decltype(_impl_.rsa_public_key_){}
    , decltype(_impl_.eax_key_){}
    , decltype(_impl_.req_ipv4_){}
    , decltype(_impl_.req_ipv6_){}
    , decltype(_impl_.req_rsa_public_key_){}
    , decltype(_impl_.req_eax_key_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.ipv4_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ipv4_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ipv4()) {
    _this->_impl_.ipv4_.Set(from._internal_ipv4(), 
      _this->GetArenaForAllocation());
  }
  _impl_.ipv6_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ipv6_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ipv6()) {
    _this->_impl_.ipv6_.Set(from._internal_ipv6(), 
      _this->GetArenaForAllocation());
  }
  _impl_.rsa_public_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.rsa_public_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_rsa_public_key()) {
    _this->_impl_.rsa_public_key_.Set(from._internal_rsa_public_key(), 
      _this->GetArenaForAllocation());
  }
  _impl_.eax_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.eax_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_eax_key()) {
    _this->_impl_.eax_key_.Set(from._internal_eax_key(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.req_ipv4_, &from._impl_.req_ipv4_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.req_eax_key_) -
    reinterpret_cast<char*>(&_impl_.req_ipv4_)) + sizeof(_impl_.req_eax_key_));
  // @@protoc_insertion_point(copy_constructor:np2ps.Credentials)
}

inline void Credentials::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ipv4_){}
    , decltype(_impl_.ipv6_){}
    , decltype(_impl_.rsa_public_key_){}
    , decltype(_impl_.eax_key_){}
    , decltype(_impl_.req_ipv4_){false}
    , decltype(_impl_.req_ipv6_){false}
    , decltype(_impl_.req_rsa_public_key_){false}
    , decltype(_impl_.req_eax_key_){false}
  };
  _impl_.ipv4_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ipv4_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.ipv6_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ipv6_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.rsa_public_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.rsa_public_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.eax_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.eax_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Credentials::~Credentials() {
  // @@protoc_insertion_point(destructor:np2ps.Credentials)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Credentials::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ipv4_.Destroy();
  _impl_.ipv6_.Destroy();
  _impl_.rsa_public_key_.Destroy();
  _impl_.eax_key_.Destroy();
}

void Credentials::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Credentials::Clear() {
// @@protoc_insertion_point(message_clear_start:np2ps.Credentials)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.ipv4_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.ipv6_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.rsa_public_key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.eax_key_.ClearNonDefaultToEmpty();
    }
  }
  ::memset(&_impl_.req_ipv4_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.req_eax_key_) -
      reinterpret_cast<char*>(&_impl_.req_ipv4_)) + sizeof(_impl_.req_eax_key_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Credentials::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string ipv4 = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_ipv4();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "np2ps.Credentials.ipv4"));
        } else
          goto handle_unusual;
        continue;
      // optional string ipv6 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_ipv6();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "np2ps.Credentials.ipv6"));
        } else
          goto handle_unusual;
        continue;
      // optional string rsa_public_key = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_rsa_public_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "np2ps.Credentials.rsa_public_key"));
        } else
          goto handle_unusual;
        continue;
      // optional string eax_key = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_eax_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "np2ps.Credentials.eax_key"));
        } else
          goto handle_unusual;
        continue;
      // bool req_ipv4 = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.req_ipv4_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool req_ipv6 = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.req_ipv6_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool req_rsa_public_key = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _impl_.req_rsa_public_key_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool req_eax_key = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _impl_.req_eax_key_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Credentials::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:np2ps.Credentials)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional string ipv4 = 1;
  if (_internal_has_ipv4()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_ipv4().data(), static_cast<int>(this->_internal_ipv4().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "np2ps.Credentials.ipv4");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_ipv4(), target);
  }

  // optional string ipv6 = 2;
  if (_internal_has_ipv6()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_ipv6().data(), static_cast<int>(this->_internal_ipv6().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "np2ps.Credentials.ipv6");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_ipv6(), target);
  }

  // optional string rsa_public_key = 3;
  if (_internal_has_rsa_public_key()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_rsa_public_key().data(), static_cast<int>(this->_internal_rsa_public_key().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "np2ps.Credentials.rsa_public_key");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_rsa_public_key(), target);
  }

  // optional string eax_key = 4;
  if (_internal_has_eax_key()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_eax_key().data(), static_cast<int>(this->_internal_eax_key().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "np2ps.Credentials.eax_key");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_eax_key(), target);
  }

  // bool req_ipv4 = 5;
  if (this->_internal_req_ipv4() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_req_ipv4(), target);
  }

  // bool req_ipv6 = 6;
  if (this->_internal_req_ipv6() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_req_ipv6(), target);
  }

  // bool req_rsa_public_key = 7;
  if (this->_internal_req_rsa_public_key() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_req_rsa_public_key(), target);
  }

  // bool req_eax_key = 8;
  if (this->_internal_req_eax_key() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_req_eax_key(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:np2ps.Credentials)
  return target;
}

size_t Credentials::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:np2ps.Credentials)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string ipv4 = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_ipv4());
    }

    // optional string ipv6 = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_ipv6());
    }

    // optional string rsa_public_key = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_rsa_public_key());
    }

    // optional string eax_key = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_eax_key());
    }

  }
  // bool req_ipv4 = 5;
  if (this->_internal_req_ipv4() != 0) {
    total_size += 1 + 1;
  }

  // bool req_ipv6 = 6;
  if (this->_internal_req_ipv6() != 0) {
    total_size += 1 + 1;
  }

  // bool req_rsa_public_key = 7;
  if (this->_internal_req_rsa_public_key() != 0) {
    total_size += 1 + 1;
  }

  // bool req_eax_key = 8;
  if (this->_internal_req_eax_key() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Credentials::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Credentials::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Credentials::GetClassData() const { return &_class_data_; }


void Credentials::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Credentials*>(&to_msg);
  auto& from = static_cast<const Credentials&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:np2ps.Credentials)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_ipv4(from._internal_ipv4());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_ipv6(from._internal_ipv6());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_rsa_public_key(from._internal_rsa_public_key());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_eax_key(from._internal_eax_key());
    }
  }
  if (from._internal_req_ipv4() != 0) {
    _this->_internal_set_req_ipv4(from._internal_req_ipv4());
  }
  if (from._internal_req_ipv6() != 0) {
    _this->_internal_set_req_ipv6(from._internal_req_ipv6());
  }
  if (from._internal_req_rsa_public_key() != 0) {
    _this->_internal_set_req_rsa_public_key(from._internal_req_rsa_public_key());
  }
  if (from._internal_req_eax_key() != 0) {
    _this->_internal_set_req_eax_key(from._internal_req_eax_key());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Credentials::CopyFrom(const Credentials& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:np2ps.Credentials)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Credentials::IsInitialized() const {
  return true;
}

void Credentials::InternalSwap(Credentials* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.ipv4_, lhs_arena,
      &other->_impl_.ipv4_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.ipv6_, lhs_arena,
      &other->_impl_.ipv6_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.rsa_public_key_, lhs_arena,
      &other->_impl_.rsa_public_key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.eax_key_, lhs_arena,
      &other->_impl_.eax_key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Credentials, _impl_.req_eax_key_)
      + sizeof(Credentials::_impl_.req_eax_key_)
      - PROTOBUF_FIELD_OFFSET(Credentials, _impl_.req_ipv4_)>(
          reinterpret_cast<char*>(&_impl_.req_ipv4_),
          reinterpret_cast<char*>(&other->_impl_.req_ipv4_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Credentials::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2eproto_getter, &descriptor_table_messages_2eproto_once,
      file_level_metadata_messages_2eproto[9]);
}

// ===================================================================

class SymmetricKey::_Internal {
 public:
};

SymmetricKey::SymmetricKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:np2ps.SymmetricKey)
}
SymmetricKey::SymmetricKey(const SymmetricKey& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SymmetricKey* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.key_){}
    , decltype(_impl_.signature_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_key().empty()) {
    _this->_impl_.key_.Set(from._internal_key(), 
      _this->GetArenaForAllocation());
  }
  _impl_.signature_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.signature_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_signature().empty()) {
    _this->_impl_.signature_.Set(from._internal_signature(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:np2ps.SymmetricKey)
}

inline void SymmetricKey::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.key_){}
    , decltype(_impl_.signature_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.signature_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.signature_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SymmetricKey::~SymmetricKey() {
  // @@protoc_insertion_point(destructor:np2ps.SymmetricKey)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SymmetricKey::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.key_.Destroy();
  _impl_.signature_.Destroy();
}

void SymmetricKey::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SymmetricKey::Clear() {
// @@protoc_insertion_point(message_clear_start:np2ps.SymmetricKey)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.key_.ClearToEmpty();
  _impl_.signature_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SymmetricKey::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes signature = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_signature();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SymmetricKey::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:np2ps.SymmetricKey)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes key = 1;
  if (!this->_internal_key().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_key(), target);
  }

  // bytes signature = 2;
  if (!this->_internal_signature().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_signature(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:np2ps.SymmetricKey)
  return target;
}

size_t SymmetricKey::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:np2ps.SymmetricKey)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes key = 1;
  if (!this->_internal_key().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_key());
  }

  // bytes signature = 2;
  if (!this->_internal_signature().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_signature());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SymmetricKey::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SymmetricKey::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SymmetricKey::GetClassData() const { return &_class_data_; }


void SymmetricKey::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SymmetricKey*>(&to_msg);
  auto& from = static_cast<const SymmetricKey&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:np2ps.SymmetricKey)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_key().empty()) {
    _this->_internal_set_key(from._internal_key());
  }
  if (!from._internal_signature().empty()) {
    _this->_internal_set_signature(from._internal_signature());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SymmetricKey::CopyFrom(const SymmetricKey& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:np2ps.SymmetricKey)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SymmetricKey::IsInitialized() const {
  return true;
}

void SymmetricKey::InternalSwap(SymmetricKey* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.key_, lhs_arena,
      &other->_impl_.key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.signature_, lhs_arena,
      &other->_impl_.signature_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata SymmetricKey::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2eproto_getter, &descriptor_table_messages_2eproto_once,
      file_level_metadata_messages_2eproto[10]);
}

// ===================================================================

class PublicKey::_Internal {
 public:
};

PublicKey::PublicKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:np2ps.PublicKey)
}
PublicKey::PublicKey(const PublicKey& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PublicKey* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.key_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_key().empty()) {
    _this->_impl_.key_.Set(from._internal_key(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:np2ps.PublicKey)
}

inline void PublicKey::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.key_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PublicKey::~PublicKey() {
  // @@protoc_insertion_point(destructor:np2ps.PublicKey)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PublicKey::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.key_.Destroy();
}

void PublicKey::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PublicKey::Clear() {
// @@protoc_insertion_point(message_clear_start:np2ps.PublicKey)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.key_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PublicKey::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PublicKey::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:np2ps.PublicKey)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes key = 1;
  if (!this->_internal_key().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_key(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:np2ps.PublicKey)
  return target;
}

size_t PublicKey::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:np2ps.PublicKey)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes key = 1;
  if (!this->_internal_key().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_key());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PublicKey::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PublicKey::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PublicKey::GetClassData() const { return &_class_data_; }


void PublicKey::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PublicKey*>(&to_msg);
  auto& from = static_cast<const PublicKey&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:np2ps.PublicKey)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_key().empty()) {
    _this->_internal_set_key(from._internal_key());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PublicKey::CopyFrom(const PublicKey& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:np2ps.PublicKey)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PublicKey::IsInitialized() const {
  return true;
}

void PublicKey::InternalSwap(PublicKey* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.key_, lhs_arena,
      &other->_impl_.key_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata PublicKey::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2eproto_getter, &descriptor_table_messages_2eproto_once,
      file_level_metadata_messages_2eproto[11]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace np2ps
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::np2ps::Message*
Arena::CreateMaybeMessage< ::np2ps::Message >(Arena* arena) {
  return Arena::CreateMessageInternal< ::np2ps::Message >(arena);
}
template<> PROTOBUF_NOINLINE ::np2ps::ArticleAll*
Arena::CreateMaybeMessage< ::np2ps::ArticleAll >(Arena* arena) {
  return Arena::CreateMessageInternal< ::np2ps::ArticleAll >(arena);
}
template<> PROTOBUF_NOINLINE ::np2ps::ArticleHeader*
Arena::CreateMaybeMessage< ::np2ps::ArticleHeader >(Arena* arena) {
  return Arena::CreateMessageInternal< ::np2ps::ArticleHeader >(arena);
}
template<> PROTOBUF_NOINLINE ::np2ps::ArticleList*
Arena::CreateMaybeMessage< ::np2ps::ArticleList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::np2ps::ArticleList >(arena);
}
template<> PROTOBUF_NOINLINE ::np2ps::ArticleSolicitation*
Arena::CreateMaybeMessage< ::np2ps::ArticleSolicitation >(Arena* arena) {
  return Arena::CreateMessageInternal< ::np2ps::ArticleSolicitation >(arena);
}
template<> PROTOBUF_NOINLINE ::np2ps::UserIsMember*
Arena::CreateMaybeMessage< ::np2ps::UserIsMember >(Arena* arena) {
  return Arena::CreateMessageInternal< ::np2ps::UserIsMember >(arena);
}
template<> PROTOBUF_NOINLINE ::np2ps::ArticleDataUpdate*
Arena::CreateMaybeMessage< ::np2ps::ArticleDataUpdate >(Arena* arena) {
  return Arena::CreateMessageInternal< ::np2ps::ArticleDataUpdate >(arena);
}
template<> PROTOBUF_NOINLINE ::np2ps::UpdateMargin*
Arena::CreateMaybeMessage< ::np2ps::UpdateMargin >(Arena* arena) {
  return Arena::CreateMessageInternal< ::np2ps::UpdateMargin >(arena);
}
template<> PROTOBUF_NOINLINE ::np2ps::UpdateArticle*
Arena::CreateMaybeMessage< ::np2ps::UpdateArticle >(Arena* arena) {
  return Arena::CreateMessageInternal< ::np2ps::UpdateArticle >(arena);
}
template<> PROTOBUF_NOINLINE ::np2ps::Credentials*
Arena::CreateMaybeMessage< ::np2ps::Credentials >(Arena* arena) {
  return Arena::CreateMessageInternal< ::np2ps::Credentials >(arena);
}
template<> PROTOBUF_NOINLINE ::np2ps::SymmetricKey*
Arena::CreateMaybeMessage< ::np2ps::SymmetricKey >(Arena* arena) {
  return Arena::CreateMessageInternal< ::np2ps::SymmetricKey >(arena);
}
template<> PROTOBUF_NOINLINE ::np2ps::PublicKey*
Arena::CreateMaybeMessage< ::np2ps::PublicKey >(Arena* arena) {
  return Arena::CreateMessageInternal< ::np2ps::PublicKey >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
